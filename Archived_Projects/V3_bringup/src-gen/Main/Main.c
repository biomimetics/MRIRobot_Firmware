// Code generated by the Lingua Franca compiler from:
// file://Users/naichenzhao/Desktop/BML/MRIRobotProject/MRIRobot/Firmware/V3_bringup/src/Main.lf
#define LOG_LEVEL 2

#include <limits.h>
#include "low_level_platform/api/low_level_platform.h"
#include "include/api/schedule.h"
#include "include/core/reactor.h"
#include "include/core/reactor_common.h"
#include "include/core/mixed_radix.h"
#include "include/core/port.h"
#include "include/core/environment.h"
int lf_reactor_c_main(int argc, const char* argv[]);
int main(void) {
   return lf_reactor_c_main(0, NULL);
}
void lf_set_default_command_line_options() {}
#include "_qdec.h"
#include "_usm.h"
#include "_pidcontroller.h"
#include "_motordriver.h"
#include "_home.h"
#include "_ros_interface.h"
#include "_main_main.h"
typedef enum {
    main_main,
    _num_enclaves
} _enclave_id;
// The global array of environments associated with each enclave
environment_t envs[_num_enclaves];
// 'Create' and initialize the environments in the program
void lf_create_environments() {
    environment_init(&envs[main_main],"Main",main_main,_lf_number_of_workers,10,4,0,0,65,1,0,0,NULL);
}
// Update the pointer argument to point to the beginning of the environment array
// and return the size of that array
int _lf_get_environments(environment_t ** return_envs) {
   (*return_envs) = (environment_t *) envs;
   return _num_enclaves;
}
void _lf_initialize_trigger_objects() {
    int startup_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(startup_reaction_count);
    int shutdown_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(shutdown_reaction_count);
    int reset_reaction_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(reset_reaction_count);
    int timer_triggers_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(timer_triggers_count);
    int modal_state_reset_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(modal_state_reset_count);
    int modal_reactor_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(modal_reactor_count);
    int watchdog_count[_num_enclaves] = {0}; SUPPRESS_UNUSED_WARNING(watchdog_count);
    int bank_index;
    SUPPRESS_UNUSED_WARNING(bank_index);
    int watchdog_number = 0;
    SUPPRESS_UNUSED_WARNING(watchdog_number);
    _main_main_main_self_t* main_main_self[1];
    SUPPRESS_UNUSED_WARNING(main_main_self);
    _qdec_self_t* main_qdec_self[1];
    SUPPRESS_UNUSED_WARNING(main_qdec_self);
    _motordriver_self_t* main_motors_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_self);
    _usm_self_t* main_motors_usm_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_usm_self);
    _pidcontroller_self_t* main_motors_control_u0_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u0_self);
    _pidcontroller_self_t* main_motors_control_u1_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u1_self);
    _pidcontroller_self_t* main_motors_control_u2_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u2_self);
    _pidcontroller_self_t* main_motors_control_u3_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u3_self);
    _pidcontroller_self_t* main_motors_control_u4_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u4_self);
    _pidcontroller_self_t* main_motors_control_u5_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u5_self);
    _pidcontroller_self_t* main_motors_control_u6_self[1];
    SUPPRESS_UNUSED_WARNING(main_motors_control_u6_self);
    _home_self_t* main_home_self[1];
    SUPPRESS_UNUSED_WARNING(main_home_self);
    _ros_interface_self_t* main_ros_controller_self[1];
    SUPPRESS_UNUSED_WARNING(main_ros_controller_self);
    // ***** Start initializing Main of class Main
    main_main_self[0] = new__main_main();
    main_main_self[0]->base.environment = &envs[main_main];
    bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
    envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_main_self[0]->_lf__reaction_0;
    { // For scoping
        static int _initial = 1;
        main_main_self[0]->count = _initial;
    } // End scoping.
    // Initiaizing timer Main.motor_update.
    main_main_self[0]->_lf__motor_update.offset = MSEC(5);
    main_main_self[0]->_lf__motor_update.period = MSEC(10);
    // Associate timer with the environment of its parent
    envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_main_self[0]->_lf__motor_update;
    main_main_self[0]->_lf__motor_update.mode = NULL;
    // Initiaizing timer Main.switch_motor.
    main_main_self[0]->_lf__switch_motor.offset = MSEC(5);
    main_main_self[0]->_lf__switch_motor.period = MSEC(2000);
    // Associate timer with the environment of its parent
    envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_main_self[0]->_lf__switch_motor;
    main_main_self[0]->_lf__switch_motor.mode = NULL;
    // Initiaizing timer Main.HOME.home_pulse.
    main_main_self[0]->_lf__home_pulse.offset = MSEC(50);
    main_main_self[0]->_lf__home_pulse.period = MSEC(100);
    // Associate timer with the environment of its parent
    envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_main_self[0]->_lf__home_pulse;
    main_main_self[0]->_lf__home_pulse.mode = &main_main_self[0]->_lf__modes[0];;
    
    main_main_self[0]->_lf__reaction_0.deadline = NEVER;
    main_main_self[0]->_lf__reaction_1.deadline = NEVER;
    main_main_self[0]->_lf__reaction_2.deadline = NEVER;
    main_main_self[0]->_lf__reaction_3.deadline = NEVER;
    main_main_self[0]->_lf__reaction_4.deadline = NEVER;
    main_main_self[0]->_lf__reaction_5.deadline = NEVER;
    main_main_self[0]->_lf__reaction_6.deadline = NEVER;
    // Register for transition handling
    envs[main_main].modes->modal_reactor_states[modal_reactor_count[main_main]++] = &((self_base_t*)main_main_self[0])->_lf__mode_state;
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.qdec of class QDEC
        main_qdec_self[0] = new__qdec();
        main_qdec_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_qdec_self[0]->sample_period = MSEC(5);
        main_qdec_self[0]->_lf_qdec_out_width = 7;
        // Allocate memory for multiport output.
        main_qdec_self[0]->_lf_qdec_out = (_qdec_qdec_out_t*)lf_allocate(
                7, sizeof(_qdec_qdec_out_t),
                &main_qdec_self[0]->base.allocations); 
        main_qdec_self[0]->_lf_qdec_out_pointers = (_qdec_qdec_out_t**)lf_allocate(
                7, sizeof(_qdec_qdec_out_t*),
                &main_qdec_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 7; i++) {
                main_qdec_self[0]->_lf_qdec_out_pointers[i] = &(main_qdec_self[0]->_lf_qdec_out[i]);
        }
        main_qdec_self[0]->_lf_sea_out_width = 7;
        // Allocate memory for multiport output.
        main_qdec_self[0]->_lf_sea_out = (_qdec_sea_out_t*)lf_allocate(
                7, sizeof(_qdec_sea_out_t),
                &main_qdec_self[0]->base.allocations); 
        main_qdec_self[0]->_lf_sea_out_pointers = (_qdec_sea_out_t**)lf_allocate(
                7, sizeof(_qdec_sea_out_t*),
                &main_qdec_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 7; i++) {
                main_qdec_self[0]->_lf_sea_out_pointers[i] = &(main_qdec_self[0]->_lf_sea_out[i]);
        }
        // width of -2 indicates that it is not a multiport.
        main_qdec_self[0]->_lf_reset_qdec_width = -2;
        envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_qdec_self[0]->_lf__reaction_0;
        // Initiaizing timer Main.qdec.trigger.
        main_qdec_self[0]->_lf__trigger.offset = 0;
        main_qdec_self[0]->_lf__trigger.period = MSEC(5);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_qdec_self[0]->_lf__trigger;
        main_qdec_self[0]->_lf__trigger.mode = NULL;
        // Initiaizing timer Main.qdec.enable.
        main_qdec_self[0]->_lf__enable.offset = 0;
        main_qdec_self[0]->_lf__enable.period = MSEC(20);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_qdec_self[0]->_lf__enable;
        main_qdec_self[0]->_lf__enable.mode = NULL;
    
        main_qdec_self[0]->_lf__reaction_0.deadline = NEVER;
        main_qdec_self[0]->_lf__reaction_1.deadline = NEVER;
        main_qdec_self[0]->_lf__reaction_2.deadline = NEVER;
        main_qdec_self[0]->_lf__reaction_3.deadline = NEVER;
        //***** End initializing Main.qdec
    }
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.motors of class MotorDriver
        main_motors_self[0] = new__motordriver();
        main_motors_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_motors_self[0]->refresh_period = MSEC(5);
        main_motors_self[0]->_lf_target_sel_width = 7;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_target_sel = (_motordriver_target_sel_t**)lf_allocate(
                7, sizeof(_motordriver_target_sel_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_motors_self[0]->_lf_target_sel[i] = &main_motors_self[0]->_lf_default__target_sel;
        }
        main_motors_self[0]->_lf_target_speed_width = 7;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_target_speed = (_motordriver_target_speed_t**)lf_allocate(
                7, sizeof(_motordriver_target_speed_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_motors_self[0]->_lf_target_speed[i] = &main_motors_self[0]->_lf_default__target_speed;
        }
        main_motors_self[0]->_lf_target_pos_width = 7;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_target_pos = (_motordriver_target_pos_t**)lf_allocate(
                7, sizeof(_motordriver_target_pos_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_motors_self[0]->_lf_target_pos[i] = &main_motors_self[0]->_lf_default__target_pos;
        }
        main_motors_self[0]->_lf_qdec_current_width = 7;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_qdec_current = (_motordriver_qdec_current_t**)lf_allocate(
                7, sizeof(_motordriver_qdec_current_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_motors_self[0]->_lf_qdec_current[i] = &main_motors_self[0]->_lf_default__qdec_current;
        }
        main_motors_self[0]->_lf_qdec_sea_width = 7;
        // Allocate memory for multiport inputs.
        main_motors_self[0]->_lf_qdec_sea = (_motordriver_qdec_sea_t**)lf_allocate(
                7, sizeof(_motordriver_qdec_sea_t*),
                &main_motors_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_motors_self[0]->_lf_qdec_sea[i] = &main_motors_self[0]->_lf_default__qdec_sea;
        }
        { // For scoping
            static bool _initial[7] = {0,0,0,0,0,0,0};
            main_motors_self[0]->sel = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[7] = {0,0,0,0,0,0,0};
            main_motors_self[0]->speed_spc = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[7] = {0,0,0,0,0,0,0};
            main_motors_self[0]->speed_posc = _initial;
        } // End scoping.
        // Initiaizing timer Main.motors.trigger.
        main_motors_self[0]->_lf__trigger.offset = 0;
        main_motors_self[0]->_lf__trigger.period = MSEC(5);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_motors_self[0]->_lf__trigger;
        main_motors_self[0]->_lf__trigger.mode = NULL;
    
        main_motors_self[0]->_lf__reaction_0.deadline = NEVER;
        main_motors_self[0]->_lf__reaction_1.deadline = NEVER;
        main_motors_self[0]->_lf__reaction_2.deadline = NEVER;
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.usm of class USM
            main_motors_usm_self[0] = new__usm();
            main_motors_usm_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_0_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_1_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_2_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_3_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_4_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_5_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_usm_self[0]->_lf_set_speed_6_width = -2;
            envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_motors_usm_self[0]->_lf__reaction_0;
    
            main_motors_usm_self[0]->_lf__reaction_0.deadline = NEVER;
            main_motors_usm_self[0]->_lf__reaction_1.deadline = NEVER;
            //***** End initializing Main.motors.usm
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u0 of class PIDController
            main_motors_control_u0_self[0] = new__pidcontroller();
            main_motors_control_u0_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u0_self[0]->Kp = 5;
            main_motors_control_u0_self[0]->Ki = 0;
            main_motors_control_u0_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u0_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u0_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u0_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u0_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u0_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u0_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u0_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u0_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u0_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u0
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u1 of class PIDController
            main_motors_control_u1_self[0] = new__pidcontroller();
            main_motors_control_u1_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u1_self[0]->Kp = 5;
            main_motors_control_u1_self[0]->Ki = 0;
            main_motors_control_u1_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u1_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u1_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u1_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u1_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u1_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u1_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u1_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u1_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u1_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u1
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u2 of class PIDController
            main_motors_control_u2_self[0] = new__pidcontroller();
            main_motors_control_u2_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u2_self[0]->Kp = 5;
            main_motors_control_u2_self[0]->Ki = 0;
            main_motors_control_u2_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u2_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u2_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u2_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u2_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u2_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u2_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u2_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u2_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u2_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u2
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u3 of class PIDController
            main_motors_control_u3_self[0] = new__pidcontroller();
            main_motors_control_u3_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u3_self[0]->Kp = 5;
            main_motors_control_u3_self[0]->Ki = 0;
            main_motors_control_u3_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u3_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u3_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u3_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u3_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u3_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u3_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u3_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u3_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u3_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u3
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u4 of class PIDController
            main_motors_control_u4_self[0] = new__pidcontroller();
            main_motors_control_u4_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u4_self[0]->Kp = 5;
            main_motors_control_u4_self[0]->Ki = 0;
            main_motors_control_u4_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u4_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u4_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u4_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u4_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u4_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u4_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u4_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u4_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u4_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u4
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u5 of class PIDController
            main_motors_control_u5_self[0] = new__pidcontroller();
            main_motors_control_u5_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u5_self[0]->Kp = 5;
            main_motors_control_u5_self[0]->Ki = 0;
            main_motors_control_u5_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u5_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u5_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u5_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u5_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u5_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u5_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u5_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u5_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u5_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u5
        }
        {
            _motordriver_self_t *self = main_motors_self[0];
            // ***** Start initializing Main.motors.control_u6 of class PIDController
            main_motors_control_u6_self[0] = new__pidcontroller();
            main_motors_control_u6_self[0]->base.environment = &envs[main_main];
            bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
            main_motors_control_u6_self[0]->Kp = 5;
            main_motors_control_u6_self[0]->Ki = 0;
            main_motors_control_u6_self[0]->Kd = 1;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u6_self[0]->_lf_out_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u6_self[0]->_lf_current_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u6_self[0]->_lf_sea_pos_width = -2;
            // width of -2 indicates that it is not a multiport.
            main_motors_control_u6_self[0]->_lf_target_pos_width = -2;
            { // For scoping
                static float _initial = 0;
                main_motors_control_u6_self[0]->last_pos = _initial;
            } // End scoping.
            main_motors_control_u6_self[0]->prev_time = 0;
            { // For scoping
                static float _initial = 0.9;
                main_motors_control_u6_self[0]->Kw = _initial;
            } // End scoping.
            { // For scoping
                static float _initial = 0;
                main_motors_control_u6_self[0]->error_i = _initial;
            } // End scoping.
    
            main_motors_control_u6_self[0]->_lf__reaction_0.deadline = NEVER;
            //***** End initializing Main.motors.control_u6
        }
        //***** End initializing Main.motors
    }
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.home of class Home
        main_home_self[0] = new__home();
        main_home_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_home_self[0]->sample_period = MSEC(15);
        main_home_self[0]->_lf_motor_speed_width = 7;
        // Allocate memory for multiport output.
        main_home_self[0]->_lf_motor_speed = (_home_motor_speed_t*)lf_allocate(
                7, sizeof(_home_motor_speed_t),
                &main_home_self[0]->base.allocations); 
        main_home_self[0]->_lf_motor_speed_pointers = (_home_motor_speed_t**)lf_allocate(
                7, sizeof(_home_motor_speed_t*),
                &main_home_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 7; i++) {
                main_home_self[0]->_lf_motor_speed_pointers[i] = &(main_home_self[0]->_lf_motor_speed[i]);
        }
        // width of -2 indicates that it is not a multiport.
        main_home_self[0]->_lf_is_home_width = -2;
        main_home_self[0]->_lf_current_pos_width = 7;
        // Allocate memory for multiport inputs.
        main_home_self[0]->_lf_current_pos = (_home_current_pos_t**)lf_allocate(
                7, sizeof(_home_current_pos_t*),
                &main_home_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_home_self[0]->_lf_current_pos[i] = &main_home_self[0]->_lf_default__current_pos;
        }
        main_home_self[0]->_lf_sea_pos_width = 7;
        // Allocate memory for multiport inputs.
        main_home_self[0]->_lf_sea_pos = (_home_sea_pos_t**)lf_allocate(
                7, sizeof(_home_sea_pos_t*),
                &main_home_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_home_self[0]->_lf_sea_pos[i] = &main_home_self[0]->_lf_default__sea_pos;
        }
        { // For scoping
            static float _initial[7] = {-20,-10,100,0,30,30,30};
            main_home_self[0]->home_speed = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[7] = {0,0,0,0,0,0,0};
            main_home_self[0]->last_pos = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[7] = {0,0,0,0,0,0,0};
            main_home_self[0]->last_sea = _initial;
        } // End scoping.
        { // For scoping
            static float _initial[7] = {0,0,0,0,0,0,0};
            main_home_self[0]->pos_diff = _initial;
        } // End scoping.
        { // For scoping
            static int _initial[7] = {0,0,0,0,0,0,0};
            main_home_self[0]->diffzero_cnt = _initial;
        } // End scoping.
        { // For scoping
            static int _initial = 0;
            main_home_self[0]->update_cnt = _initial;
        } // End scoping.
        // Initiaizing timer Main.home.trigger.
        main_home_self[0]->_lf__trigger.offset = 0;
        main_home_self[0]->_lf__trigger.period = MSEC(15);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_home_self[0]->_lf__trigger;
        main_home_self[0]->_lf__trigger.mode = NULL;
        // Initiaizing timer Main.home.switch_update.
        main_home_self[0]->_lf__switch_update.offset = MSEC(0);
        main_home_self[0]->_lf__switch_update.period = MSEC(40);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_home_self[0]->_lf__switch_update;
        main_home_self[0]->_lf__switch_update.mode = NULL;
    
        main_home_self[0]->_lf__reaction_0.deadline = NEVER;
        main_home_self[0]->_lf__reaction_1.deadline = NEVER;
        //***** End initializing Main.home
    }
    {
        _main_main_main_self_t *self = main_main_self[0];
        // ***** Start initializing Main.ros_controller of class ROS_Interface
        main_ros_controller_self[0] = new__ros_interface();
        main_ros_controller_self[0]->base.environment = &envs[main_main];
        bank_index = 0; SUPPRESS_UNUSED_WARNING(bank_index);
        main_ros_controller_self[0]->_lf_target_pos_width = 7;
        // Allocate memory for multiport output.
        main_ros_controller_self[0]->_lf_target_pos = (_ros_interface_target_pos_t*)lf_allocate(
                7, sizeof(_ros_interface_target_pos_t),
                &main_ros_controller_self[0]->base.allocations); 
        main_ros_controller_self[0]->_lf_target_pos_pointers = (_ros_interface_target_pos_t**)lf_allocate(
                7, sizeof(_ros_interface_target_pos_t*),
                &main_ros_controller_self[0]->base.allocations); 
        // Assign each output port pointer to be used in
        // reactions to facilitate user access to output ports
        for(int i=0; i < 7; i++) {
                main_ros_controller_self[0]->_lf_target_pos_pointers[i] = &(main_ros_controller_self[0]->_lf_target_pos[i]);
        }
        main_ros_controller_self[0]->_lf_current_pos_width = 7;
        // Allocate memory for multiport inputs.
        main_ros_controller_self[0]->_lf_current_pos = (_ros_interface_current_pos_t**)lf_allocate(
                7, sizeof(_ros_interface_current_pos_t*),
                &main_ros_controller_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_ros_controller_self[0]->_lf_current_pos[i] = &main_ros_controller_self[0]->_lf_default__current_pos;
        }
        main_ros_controller_self[0]->_lf_sea_pos_width = 7;
        // Allocate memory for multiport inputs.
        main_ros_controller_self[0]->_lf_sea_pos = (_ros_interface_sea_pos_t**)lf_allocate(
                7, sizeof(_ros_interface_sea_pos_t*),
                &main_ros_controller_self[0]->base.allocations); 
        // Set inputs by default to an always absent default input.
        for (int i = 0; i < 7; i++) {
            main_ros_controller_self[0]->_lf_sea_pos[i] = &main_ros_controller_self[0]->_lf_default__sea_pos;
        }
        envs[main_main].startup_reactions[startup_reaction_count[main_main]++] = &main_ros_controller_self[0]->_lf__reaction_0;
        // Initiaizing timer Main.ros_controller.trigger_send.
        main_ros_controller_self[0]->_lf__trigger_send.offset = MSEC(500);
        main_ros_controller_self[0]->_lf__trigger_send.period = MSEC(500);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_ros_controller_self[0]->_lf__trigger_send;
        main_ros_controller_self[0]->_lf__trigger_send.mode = NULL;
        // Initiaizing timer Main.ros_controller.trigger_read.
        main_ros_controller_self[0]->_lf__trigger_read.offset = 0;
        main_ros_controller_self[0]->_lf__trigger_read.period = MSEC(20);
        // Associate timer with the environment of its parent
        envs[main_main].timer_triggers[timer_triggers_count[main_main]++] = &main_ros_controller_self[0]->_lf__trigger_read;
        main_ros_controller_self[0]->_lf__trigger_read.mode = NULL;
    
        main_ros_controller_self[0]->_lf__reaction_0.deadline = NEVER;
        main_ros_controller_self[0]->_lf__reaction_1.deadline = NEVER;
        main_ros_controller_self[0]->_lf__reaction_2.deadline = NEVER;
        main_ros_controller_self[0]->_lf__reaction_3.deadline = NEVER;
        //***** End initializing Main.ros_controller
    }
    //***** End initializing Main
    // **** Start deferred initialize for Main
    {
        // A reaction writes to a multiport of a child. Allocate memory.
        {
            main_main_self[0]->_lf_motors.target_sel_width = 7;
            // Allocate memory to store output of reaction feeding 
            // a multiport input of a contained reactor.
            main_main_self[0]->_lf_motors.target_sel = (_motordriver_target_sel_t**)lf_allocate(
                    7, sizeof(_motordriver_target_sel_t*),
                    &main_main_self[0]->base.allocations); 
            for (int i = 0; i < 7; i++) {
                main_main_self[0]->_lf_motors.target_sel[i] = (_motordriver_target_sel_t*)lf_allocate(
                        1, sizeof(_motordriver_target_sel_t),
                        &main_main_self[0]->base.allocations); 
            }
        }
        // A reaction writes to a multiport of a child. Allocate memory.
        {
            main_main_self[0]->_lf_motors.target_speed_width = 7;
            // Allocate memory to store output of reaction feeding 
            // a multiport input of a contained reactor.
            main_main_self[0]->_lf_motors.target_speed = (_motordriver_target_speed_t**)lf_allocate(
                    7, sizeof(_motordriver_target_speed_t*),
                    &main_main_self[0]->base.allocations); 
            for (int i = 0; i < 7; i++) {
                main_main_self[0]->_lf_motors.target_speed[i] = (_motordriver_target_speed_t*)lf_allocate(
                        1, sizeof(_motordriver_target_speed_t),
                        &main_main_self[0]->base.allocations); 
            }
        }
        // A reaction writes to a multiport of a child. Allocate memory.
        {
            main_main_self[0]->_lf_motors.target_pos_width = 7;
            // Allocate memory to store output of reaction feeding 
            // a multiport input of a contained reactor.
            main_main_self[0]->_lf_motors.target_pos = (_motordriver_target_pos_t**)lf_allocate(
                    7, sizeof(_motordriver_target_pos_t*),
                    &main_main_self[0]->base.allocations); 
            for (int i = 0; i < 7; i++) {
                main_main_self[0]->_lf_motors.target_pos[i] = (_motordriver_target_pos_t*)lf_allocate(
                        1, sizeof(_motordriver_target_pos_t),
                        &main_main_self[0]->base.allocations); 
            }
        }
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_1 of Main.
        main_main_self[0]->_lf__reaction_0.num_outputs = 0;
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
        }
        
        // ** End initialization for reaction 0 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_2 of Main.
        main_main_self[0]->_lf__reaction_1.num_outputs = 1;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                1, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                1, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                1, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                main_main_self[0]->_lf__reaction_1.output_produced[count++] = &main_main_self[0]->_lf_qdec.reset_qdec.is_present;
            }
        }
        
        // ** End initialization for reaction 1 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_3 of Main.
        main_main_self[0]->_lf__reaction_2.num_outputs = 0;
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
        }
        
        // ** End initialization for reaction 2 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_4 of Main.
        main_main_self[0]->_lf__reaction_3.num_outputs = 0;
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
        }
        
        // ** End initialization for reaction 3 of Main
        // Allocate memory to store pointers to the multiport output motor_speed 
        // of a contained reactor Main.home
        {
            main_main_self[0]->_lf_home.motor_speed_width = 7;
            main_main_self[0]->_lf_home.motor_speed
                    = (_home_motor_speed_t**)lf_allocate(
                            7, sizeof(_home_motor_speed_t*),
                            &main_main_self[0]->base.allocations); 
        }
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_5 of Main.
        main_main_self[0]->_lf__reaction_4.num_outputs = 14;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_4.triggers = (trigger_t***)lf_allocate(
                14, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_4.triggered_sizes = (int*)lf_allocate(
                14, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_4.output_produced = (bool**)lf_allocate(
                14, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 7; i++) {
                    main_main_self[0]->_lf__reaction_4.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_sel[i]->is_present;
                }
                count += 7;
            }
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 7; i++) {
                    main_main_self[0]->_lf__reaction_4.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_speed[i]->is_present;
                }
                count += 7;
            }
        }
        
        // ** End initialization for reaction 4 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_6 of Main.
        main_main_self[0]->_lf__reaction_5.num_outputs = 14;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_5.triggers = (trigger_t***)lf_allocate(
                14, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_5.triggered_sizes = (int*)lf_allocate(
                14, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_5.output_produced = (bool**)lf_allocate(
                14, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 7; i++) {
                    main_main_self[0]->_lf__reaction_5.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_sel[i]->is_present;
                }
                count += 7;
            }
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 7; i++) {
                    main_main_self[0]->_lf__reaction_5.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_speed[i]->is_present;
                }
                count += 7;
            }
        }
        
        // ** End initialization for reaction 5 of Main
        // Total number of outputs (single ports and multiport channels)
        // produced by reaction_7 of Main.
        main_main_self[0]->_lf__reaction_6.num_outputs = 7;
        // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
        // struct for this reaction.
        main_main_self[0]->_lf__reaction_6.triggers = (trigger_t***)lf_allocate(
                7, sizeof(trigger_t**),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_6.triggered_sizes = (int*)lf_allocate(
                7, sizeof(int),
                &main_main_self[0]->base.allocations);
        main_main_self[0]->_lf__reaction_6.output_produced = (bool**)lf_allocate(
                7, sizeof(bool*),
                &main_main_self[0]->base.allocations);
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            // Reaction writes to an input of a contained reactor.
            {
                for (int i = 0; i < 7; i++) {
                    main_main_self[0]->_lf__reaction_6.output_produced[i + count]
                            = &main_main_self[0]->_lf_motors.target_pos[i]->is_present;
                }
                count += 7;
            }
        }
        
        // ** End initialization for reaction 6 of Main
    
        // **** Start deferred initialize for Main.qdec
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of Main.qdec
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of Main.qdec
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_2.num_outputs = 14;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            main_qdec_self[0]->_lf__reaction_2.triggers = (trigger_t***)lf_allocate(
                    14, sizeof(trigger_t**),
                    &main_qdec_self[0]->base.allocations);
            main_qdec_self[0]->_lf__reaction_2.triggered_sizes = (int*)lf_allocate(
                    14, sizeof(int),
                    &main_qdec_self[0]->base.allocations);
            main_qdec_self[0]->_lf__reaction_2.output_produced = (bool**)lf_allocate(
                    14, sizeof(bool*),
                    &main_qdec_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    for (int i = 0; i < 7; i++) {
                        main_qdec_self[0]->_lf__reaction_2.output_produced[i + count]
                                = &main_qdec_self[0]->_lf_qdec_out[i].is_present;
                    }
                    count += 7;
                }
                {
                    for (int i = 0; i < 7; i++) {
                        main_qdec_self[0]->_lf__reaction_2.output_produced[i + count]
                                = &main_qdec_self[0]->_lf_sea_out[i].is_present;
                    }
                    count += 7;
                }
            }
            
            // ** End initialization for reaction 2 of Main.qdec
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_4 of Main.qdec.
            main_qdec_self[0]->_lf__reaction_3.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 3 of Main.qdec
        
        }
        // **** End of deferred initialize for Main.qdec
        // **** Start deferred initialize for Main.motors
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.motors.
            main_motors_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of Main.motors
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Main.motors.
            main_motors_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of Main.motors
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Main.motors.
            main_motors_self[0]->_lf__reaction_2.num_outputs = 7;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            main_motors_self[0]->_lf__reaction_2.triggers = (trigger_t***)lf_allocate(
                    7, sizeof(trigger_t**),
                    &main_motors_self[0]->base.allocations);
            main_motors_self[0]->_lf__reaction_2.triggered_sizes = (int*)lf_allocate(
                    7, sizeof(int),
                    &main_motors_self[0]->base.allocations);
            main_motors_self[0]->_lf__reaction_2.output_produced = (bool**)lf_allocate(
                    7, sizeof(bool*),
                    &main_motors_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_0.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_1.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_2.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_3.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_4.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_5.is_present;
                }
                // Reaction writes to an input of a contained reactor.
                {
                    main_motors_self[0]->_lf__reaction_2.output_produced[count++] = &main_motors_self[0]->_lf_usm.set_speed_6.is_present;
                }
            }
            
            // ** End initialization for reaction 2 of Main.motors
        
            // **** Start deferred initialize for Main.motors.usm
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.usm.
                main_motors_usm_self[0]->_lf__reaction_0.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 0 of Main.motors.usm
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_2 of Main.motors.usm.
                main_motors_usm_self[0]->_lf__reaction_1.num_outputs = 0;
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                }
                
                // ** End initialization for reaction 1 of Main.motors.usm
            
            }
            // **** End of deferred initialize for Main.motors.usm
            // **** Start deferred initialize for Main.motors.control_u0
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u0.
                main_motors_control_u0_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u0_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u0_self[0]->base.allocations);
                main_motors_control_u0_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u0_self[0]->base.allocations);
                main_motors_control_u0_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u0_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u0_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u0_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u0
            
            }
            // **** End of deferred initialize for Main.motors.control_u0
            // **** Start deferred initialize for Main.motors.control_u1
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u1.
                main_motors_control_u1_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u1_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u1_self[0]->base.allocations);
                main_motors_control_u1_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u1_self[0]->base.allocations);
                main_motors_control_u1_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u1_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u1_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u1_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u1
            
            }
            // **** End of deferred initialize for Main.motors.control_u1
            // **** Start deferred initialize for Main.motors.control_u2
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u2.
                main_motors_control_u2_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u2_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u2_self[0]->base.allocations);
                main_motors_control_u2_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u2_self[0]->base.allocations);
                main_motors_control_u2_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u2_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u2_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u2_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u2
            
            }
            // **** End of deferred initialize for Main.motors.control_u2
            // **** Start deferred initialize for Main.motors.control_u3
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u3.
                main_motors_control_u3_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u3_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u3_self[0]->base.allocations);
                main_motors_control_u3_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u3_self[0]->base.allocations);
                main_motors_control_u3_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u3_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u3_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u3_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u3
            
            }
            // **** End of deferred initialize for Main.motors.control_u3
            // **** Start deferred initialize for Main.motors.control_u4
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u4.
                main_motors_control_u4_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u4_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u4_self[0]->base.allocations);
                main_motors_control_u4_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u4_self[0]->base.allocations);
                main_motors_control_u4_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u4_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u4_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u4_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u4
            
            }
            // **** End of deferred initialize for Main.motors.control_u4
            // **** Start deferred initialize for Main.motors.control_u5
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u5.
                main_motors_control_u5_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u5_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u5_self[0]->base.allocations);
                main_motors_control_u5_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u5_self[0]->base.allocations);
                main_motors_control_u5_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u5_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u5_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u5_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u5
            
            }
            // **** End of deferred initialize for Main.motors.control_u5
            // **** Start deferred initialize for Main.motors.control_u6
            {
            
                // Total number of outputs (single ports and multiport channels)
                // produced by reaction_1 of Main.motors.control_u6.
                main_motors_control_u6_self[0]->_lf__reaction_0.num_outputs = 1;
                // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
                // struct for this reaction.
                main_motors_control_u6_self[0]->_lf__reaction_0.triggers = (trigger_t***)lf_allocate(
                        1, sizeof(trigger_t**),
                        &main_motors_control_u6_self[0]->base.allocations);
                main_motors_control_u6_self[0]->_lf__reaction_0.triggered_sizes = (int*)lf_allocate(
                        1, sizeof(int),
                        &main_motors_control_u6_self[0]->base.allocations);
                main_motors_control_u6_self[0]->_lf__reaction_0.output_produced = (bool**)lf_allocate(
                        1, sizeof(bool*),
                        &main_motors_control_u6_self[0]->base.allocations);
                {
                    int count = 0; SUPPRESS_UNUSED_WARNING(count);
                    {
                        main_motors_control_u6_self[0]->_lf__reaction_0.output_produced[count++] = &main_motors_control_u6_self[0]->_lf_out.is_present;
                    }
                }
                
                // ** End initialization for reaction 0 of Main.motors.control_u6
            
            }
            // **** End of deferred initialize for Main.motors.control_u6
        }
        // **** End of deferred initialize for Main.motors
        // **** Start deferred initialize for Main.home
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.home.
            main_home_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of Main.home
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Main.home.
            main_home_self[0]->_lf__reaction_1.num_outputs = 8;
            // Allocate memory for triggers[] and triggered_sizes[] on the reaction_t
            // struct for this reaction.
            main_home_self[0]->_lf__reaction_1.triggers = (trigger_t***)lf_allocate(
                    8, sizeof(trigger_t**),
                    &main_home_self[0]->base.allocations);
            main_home_self[0]->_lf__reaction_1.triggered_sizes = (int*)lf_allocate(
                    8, sizeof(int),
                    &main_home_self[0]->base.allocations);
            main_home_self[0]->_lf__reaction_1.output_produced = (bool**)lf_allocate(
                    8, sizeof(bool*),
                    &main_home_self[0]->base.allocations);
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
                {
                    for (int i = 0; i < 7; i++) {
                        main_home_self[0]->_lf__reaction_1.output_produced[i + count]
                                = &main_home_self[0]->_lf_motor_speed[i].is_present;
                    }
                    count += 7;
                }
                {
                    main_home_self[0]->_lf__reaction_1.output_produced[count++] = &main_home_self[0]->_lf_is_home.is_present;
                }
            }
            
            // ** End initialization for reaction 1 of Main.home
        
        }
        // **** End of deferred initialize for Main.home
        // **** Start deferred initialize for Main.ros_controller
        {
        
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_1 of Main.ros_controller.
            main_ros_controller_self[0]->_lf__reaction_0.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 0 of Main.ros_controller
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_2 of Main.ros_controller.
            main_ros_controller_self[0]->_lf__reaction_1.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 1 of Main.ros_controller
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_3 of Main.ros_controller.
            main_ros_controller_self[0]->_lf__reaction_2.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 2 of Main.ros_controller
            // Total number of outputs (single ports and multiport channels)
            // produced by reaction_4 of Main.ros_controller.
            main_ros_controller_self[0]->_lf__reaction_3.num_outputs = 0;
            {
                int count = 0; SUPPRESS_UNUSED_WARNING(count);
            }
            
            // ** End initialization for reaction 3 of Main.ros_controller
        
        }
        // **** End of deferred initialize for Main.ros_controller
    }
    // **** End of deferred initialize for Main
    // **** Start non-nested deferred initialize for Main
    {
        // Set number of destination reactors for port qdec.reset_qdec.
        // Iterate over range Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_qdec.reset_qdec._base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_qdec.reset_qdec._base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Set number of destination reactors for port motors.target_sel.
        // Iterate over range Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 7, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 7; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_main_self[src_runtime]->_lf_motors.target_sel[src_channel]->_base.num_destinations = 1;
                main_main_self[src_runtime]->_lf_motors.target_sel[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
                mixed_radix_incr(&range_mr);
            }
        }
        // Set number of destination reactors for port motors.target_speed.
        // Iterate over range Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)].
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 7, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 7; range_count++) {
                int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_main_self[src_runtime]->_lf_motors.target_speed[src_channel]->_base.num_destinations = 1;
                main_main_self[src_runtime]->_lf_motors.target_speed[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
                mixed_radix_incr(&range_mr);
            }
        }
        // Set number of destination reactors for port motors.target_pos.
        // Iterate over range Main.motors.target_pos(0,1)->[Main.motors.control_u0.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(1,1)->[Main.motors.control_u1.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(2,1)->[Main.motors.control_u2.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(3,1)->[Main.motors.control_u3.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(4,1)->[Main.motors.control_u4.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(5,1)->[Main.motors.control_u5.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        // Iterate over range Main.motors.target_pos(6,1)->[Main.motors.control_u6.target_pos(0,1)].
        {
            int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
            int src_channel = 6; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
            int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.num_destinations = 1;
            main_main_self[src_runtime]->_lf_motors.target_pos[src_channel]->_base.source_reactor = (self_base_t*)main_main_self[src_runtime];
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 1 of Main triggers 1 downstream reactions
                // through port Main.qdec.reset_qdec.
                main_main_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 1 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.qdec.reset_qdec
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)] and Main.qdec.reset_qdec(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 0; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.qdec.reset_qdec(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.qdec.reset_qdec's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_qdec_self[dst_runtime]->_lf__reset_qdec;
                }
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 7, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 7; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 4 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_sel.
                    main_main_self[src_runtime]->_lf__reaction_4.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 4 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_sel
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            // Iterate over range Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 7, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 7; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 4 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_speed.
                    main_main_self[src_runtime]->_lf__reaction_4.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 4 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_speed
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)] and Main.motors.target_sel(0,7).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 7, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_sel(0,7).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 7, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 7; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_sel's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_sel;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 7;
            // Iterate over ranges Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)] and Main.motors.target_speed(0,7).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 7, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_speed(0,7).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 7, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 7; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_speed's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_4.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_speed;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 7, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 7; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 5 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_sel.
                    main_main_self[src_runtime]->_lf__reaction_5.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 5 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_sel
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            // Iterate over range Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 7, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 7; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Reaction 5 of Main triggers 1 downstream reactions
                    // through port Main.motors.target_speed.
                    main_main_self[src_runtime]->_lf__reaction_5.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 5 of Main, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.target_speed
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_main_self[src_runtime]->base.allocations); 
                    main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime]++] = trigger_array;
                    mixed_radix_incr(&range_mr);
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)] and Main.motors.target_sel(0,7).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 7, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_sel(0,7).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 7, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 7; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_sel's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_sel;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 7;
            // Iterate over ranges Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)] and Main.motors.target_speed(0,7).
            {
                int src_start[] =  { 0, 0 };
                int src_value[] =  { 0, 0 }; // Will be incremented.
                int src_radixes[] = { 7, 1 };
                int src_permutation[] = { 0, 1 };
                mixed_radix_int_t src_range_mr = {
                    2,
                    src_value,
                    src_radixes,
                    src_permutation
                };
                // Iterate over range Main.motors.target_speed(0,7).
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 7, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 7; range_count++) {
                        int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(dst_runtime);
                        int dst_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(dst_channel);
                        int dst_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(dst_bank);
                        int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = src_range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = src_range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Point to destination port Main.motors.target_speed's trigger struct.
                        main_main_self[src_runtime]->_lf__reaction_5.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf__target_speed;
                        mixed_radix_incr(&src_range_mr);
                        if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                            // Start over with the source.
                            for (int i = 0; i < src_range_mr.size; i++) {
                                src_range_mr.digits[i] = src_start[i];
                            }
                        }
                        mixed_radix_incr(&range_mr);
                    }
                }
            }
        }
        {
            int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            // Iterate over range Main.motors.target_pos(0,1)->[Main.motors.control_u0.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(1,1)->[Main.motors.control_u1.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(2,1)->[Main.motors.control_u2.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(3,1)->[Main.motors.control_u3.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(4,1)->[Main.motors.control_u4.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(5,1)->[Main.motors.control_u5.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            // Iterate over range Main.motors.target_pos(6,1)->[Main.motors.control_u6.target_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 6; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                // Reaction 6 of Main triggers 1 downstream reactions
                // through port Main.motors.target_pos.
                main_main_self[src_runtime]->_lf__reaction_6.triggered_sizes[triggers_index[src_runtime]] = 1;
                // For reaction 6 of Main, allocate an
                // array of trigger pointers for downstream reactions through port Main.motors.target_pos
                trigger_t** trigger_array = (trigger_t**)lf_allocate(
                        1, sizeof(trigger_t*),
                        &main_main_self[src_runtime]->base.allocations); 
                main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime]++] = trigger_array;
            }
            for (int i = 0; i < 1; i++) triggers_index[i] = 0;
            // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_u0.target_pos(0,1)] and Main.motors.control_u0.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 0; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u0.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u0.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u0_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_u1.target_pos(0,1)] and Main.motors.control_u1.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 1; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u1.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u1.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u1_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(2,1)->[Main.motors.control_u2.target_pos(0,1)] and Main.motors.control_u2.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 2; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u2.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u2.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u2_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(3,1)->[Main.motors.control_u3.target_pos(0,1)] and Main.motors.control_u3.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 3; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u3.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u3.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u3_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(4,1)->[Main.motors.control_u4.target_pos(0,1)] and Main.motors.control_u4.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 4; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u4.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u4.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u4_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(5,1)->[Main.motors.control_u5.target_pos(0,1)] and Main.motors.control_u5.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 5; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u5.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u5.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u5_self[dst_runtime]->_lf__target_pos;
                }
            }
            // Iterate over ranges Main.motors.target_pos(6,1)->[Main.motors.control_u6.target_pos(0,1)] and Main.motors.control_u6.target_pos(0,1).
            {
                int src_runtime = 0; // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = 6; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = 0; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                // Iterate over range Main.motors.control_u6.target_pos(0,1).
                {
                    int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                    int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                    int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Point to destination port Main.motors.control_u6.target_pos's trigger struct.
                    main_main_self[src_runtime]->_lf__reaction_6.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u6_self[dst_runtime]->_lf__target_pos;
                }
            }
        }
    
        // **** Start non-nested deferred initialize for Main.qdec
        {
        
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.qdec_out.
            // Iterate over range Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 6; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.num_destinations = 3;
                main_qdec_self[src_runtime]->_lf_qdec_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
            }
            // For reference counting, set num_destinations for port Main.qdec.sea_out.
            // Iterate over range Main.qdec.sea_out(0,7)->[Main.home.sea_pos(0,7)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 7, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 7; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.num_destinations = 1;
                    main_qdec_self[src_runtime]->_lf_sea_out[src_channel]._base.source_reactor = (self_base_t*)main_qdec_self[src_runtime];
                    mixed_radix_incr(&range_mr);
                }
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 1; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 2; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 3; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 4; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 5; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 6; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.qdec triggers 3 downstream reactions
                    // through port Main.qdec.qdec_out.
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 3;
                    // For reaction 2 of Main.qdec, allocate an
                    // array of trigger pointers for downstream reactions through port Main.qdec.qdec_out
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            3, sizeof(trigger_t*),
                            &main_qdec_self[src_runtime]->base.allocations); 
                    main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.qdec.sea_out(0,7)->[Main.home.sea_pos(0,7)].
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 7, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 7; range_count++) {
                        int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Reaction 2 of Main.qdec triggers 1 downstream reactions
                        // through port Main.qdec.sea_out.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 2 of Main.qdec, allocate an
                        // array of trigger pointers for downstream reactions through port Main.qdec.sea_out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_qdec_self[src_runtime]->base.allocations); 
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                        mixed_radix_incr(&range_mr);
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_u0.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u0.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u0.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u0_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] and Main.ros_controller.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] and Main.home.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] and Main.motors.control_u1.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u1.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u1.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u1_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] and Main.ros_controller.current_pos(1,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(1,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] and Main.home.current_pos(1,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 1; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(1,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] and Main.motors.control_u2.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 2; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u2.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u2.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u2_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] and Main.home.current_pos(2,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 2; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(2,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 2; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] and Main.ros_controller.current_pos(2,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 2; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(2,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 2; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] and Main.motors.control_u3.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 3; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u3.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u3.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u3_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] and Main.ros_controller.current_pos(3,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 3; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(3,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 3; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] and Main.home.current_pos(3,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 3; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(3,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 3; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] and Main.motors.control_u4.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 4; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u4.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u4.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u4_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] and Main.home.current_pos(4,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 4; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(4,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 4; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] and Main.ros_controller.current_pos(4,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 4; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(4,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 4; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] and Main.motors.control_u5.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 5; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u5.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u5.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_control_u5_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] and Main.ros_controller.current_pos(5,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 5; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(5,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 5; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] and Main.home.current_pos(5,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 5; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(5,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 5; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] and Main.ros_controller.current_pos(6,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 6; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.ros_controller.current_pos(6,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 6; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.ros_controller.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_ros_controller_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] and Main.home.current_pos(6,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 6; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.current_pos(6,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 6; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.home.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][1] = &main_home_self[dst_runtime]->_lf__current_pos;
                    }
                }
                // Iterate over ranges Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] and Main.motors.control_u6.current_pos(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 6; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.control_u6.current_pos(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.control_u6.current_pos's trigger struct.
                        main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][2] = &main_motors_control_u6_self[dst_runtime]->_lf__current_pos;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 7;
                // Iterate over ranges Main.qdec.sea_out(0,7)->[Main.home.sea_pos(0,7)] and Main.home.sea_pos(0,7).
                {
                    int src_start[] =  { 0, 0 };
                    int src_value[] =  { 0, 0 }; // Will be incremented.
                    int src_radixes[] = { 7, 1 };
                    int src_permutation[] = { 0, 1 };
                    mixed_radix_int_t src_range_mr = {
                        2,
                        src_value,
                        src_radixes,
                        src_permutation
                    };
                    // Iterate over range Main.home.sea_pos(0,7).
                    {
                        int range_start[] =  { 0, 0 };
                        int range_radixes[] = { 7, 1 };
                        int permutation[] = { 0, 1 };
                        mixed_radix_int_t range_mr = {
                            2,
                            range_start,
                            range_radixes,
                            permutation
                        };
                        for (int range_count = 0; range_count < 0 + 7; range_count++) {
                            int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(dst_runtime);
                            int dst_channel = range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(dst_channel);
                            int dst_bank = range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(dst_bank);
                            int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = src_range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = src_range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Point to destination port Main.home.sea_pos's trigger struct.
                            main_qdec_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_home_self[dst_runtime]->_lf__sea_pos;
                            mixed_radix_incr(&src_range_mr);
                            if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                                // Start over with the source.
                                for (int i = 0; i < src_range_mr.size; i++) {
                                    src_range_mr.digits[i] = src_start[i];
                                }
                            }
                            mixed_radix_incr(&range_mr);
                        }
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for Main.qdec
        // **** Start non-nested deferred initialize for Main.motors
        {
            // Set number of destination reactors for port usm.set_speed_0.
            // Iterate over range Main.motors.usm.set_speed_0(0,1)->[Main.motors.usm.set_speed_0(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_0._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_0._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_1.
            // Iterate over range Main.motors.usm.set_speed_1(0,1)->[Main.motors.usm.set_speed_1(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_1._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_1._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_2.
            // Iterate over range Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_2._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_2._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_3.
            // Iterate over range Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_3._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_3._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_4.
            // Iterate over range Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_4._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_4._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_5.
            // Iterate over range Main.motors.usm.set_speed_5(0,1)->[Main.motors.usm.set_speed_5(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_5._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_5._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
            // Set number of destination reactors for port usm.set_speed_6.
            // Iterate over range Main.motors.usm.set_speed_6(0,1)->[Main.motors.usm.set_speed_6(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_motors_self[src_runtime]->_lf_usm.set_speed_6._base.num_destinations = 1;
                main_motors_self[src_runtime]->_lf_usm.set_speed_6._base.source_reactor = (self_base_t*)main_motors_self[src_runtime];
            }
        
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range Main.motors.usm.set_speed_0(0,1)->[Main.motors.usm.set_speed_0(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_0.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_0
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_1(0,1)->[Main.motors.usm.set_speed_1(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_1.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_1
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_2.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_2
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_3.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_3
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_4.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_4
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_5(0,1)->[Main.motors.usm.set_speed_5(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_5.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_5
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                // Iterate over range Main.motors.usm.set_speed_6(0,1)->[Main.motors.usm.set_speed_6(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 2 of Main.motors triggers 1 downstream reactions
                    // through port Main.motors.usm.set_speed_6.
                    main_motors_self[src_runtime]->_lf__reaction_2.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 2 of Main.motors, allocate an
                    // array of trigger pointers for downstream reactions through port Main.motors.usm.set_speed_6
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_motors_self[src_runtime]->base.allocations); 
                    main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges Main.motors.usm.set_speed_0(0,1)->[Main.motors.usm.set_speed_0(0,1)] and Main.motors.usm.set_speed_0(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_0(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_0's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_0;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 1;
                // Iterate over ranges Main.motors.usm.set_speed_1(0,1)->[Main.motors.usm.set_speed_1(0,1)] and Main.motors.usm.set_speed_1(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_1(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_1's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_1;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 2;
                // Iterate over ranges Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)] and Main.motors.usm.set_speed_2(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_2(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_2's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_2;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 3;
                // Iterate over ranges Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)] and Main.motors.usm.set_speed_3(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_3(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_3's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_3;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 4;
                // Iterate over ranges Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)] and Main.motors.usm.set_speed_4(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_4(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_4's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_4;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 5;
                // Iterate over ranges Main.motors.usm.set_speed_5(0,1)->[Main.motors.usm.set_speed_5(0,1)] and Main.motors.usm.set_speed_5(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_5(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_5's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_5;
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 6;
                // Iterate over ranges Main.motors.usm.set_speed_6(0,1)->[Main.motors.usm.set_speed_6(0,1)] and Main.motors.usm.set_speed_6(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.motors.usm.set_speed_6(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Point to destination port Main.motors.usm.set_speed_6's trigger struct.
                        main_motors_self[src_runtime]->_lf__reaction_2.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_usm_self[dst_runtime]->_lf__set_speed_6;
                    }
                }
            }
        
            // **** Start non-nested deferred initialize for Main.motors.usm
            {
            
            
            
            
            }
            // **** End of non-nested deferred initialize for Main.motors.usm
            // **** Start non-nested deferred initialize for Main.motors.control_u0
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u0.out.
                // Iterate over range Main.motors.control_u0.out(0,1)->[Main.motors.control_u0.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u0_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u0_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u0_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u0.out(0,1)->[Main.motors.control_u0.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u0 triggers 1 downstream reactions
                        // through port Main.motors.control_u0.out.
                        main_motors_control_u0_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u0, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u0.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u0_self[src_runtime]->base.allocations); 
                        main_motors_control_u0_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u0.out(0,1)->[Main.motors.control_u0.out(0,1)] and Main.motors.control_u0.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u0.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u0.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u0_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u0.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u0
            // **** Start non-nested deferred initialize for Main.motors.control_u1
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u1.out.
                // Iterate over range Main.motors.control_u1.out(0,1)->[Main.motors.control_u1.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u1_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u1_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u1_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u1.out(0,1)->[Main.motors.control_u1.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u1 triggers 1 downstream reactions
                        // through port Main.motors.control_u1.out.
                        main_motors_control_u1_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u1, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u1.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u1_self[src_runtime]->base.allocations); 
                        main_motors_control_u1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u1.out(0,1)->[Main.motors.control_u1.out(0,1)] and Main.motors.control_u1.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u1.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u1.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u1_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u1.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u1
            // **** Start non-nested deferred initialize for Main.motors.control_u2
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u2.out.
                // Iterate over range Main.motors.control_u2.out(0,1)->[Main.motors.control_u2.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u2_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u2_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u2_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u2.out(0,1)->[Main.motors.control_u2.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u2 triggers 1 downstream reactions
                        // through port Main.motors.control_u2.out.
                        main_motors_control_u2_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u2, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u2.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u2_self[src_runtime]->base.allocations); 
                        main_motors_control_u2_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u2.out(0,1)->[Main.motors.control_u2.out(0,1)] and Main.motors.control_u2.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u2.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u2.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u2_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u2.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u2
            // **** Start non-nested deferred initialize for Main.motors.control_u3
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u3.out.
                // Iterate over range Main.motors.control_u3.out(0,1)->[Main.motors.control_u3.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u3_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u3_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u3_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u3.out(0,1)->[Main.motors.control_u3.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u3 triggers 1 downstream reactions
                        // through port Main.motors.control_u3.out.
                        main_motors_control_u3_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u3, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u3.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u3_self[src_runtime]->base.allocations); 
                        main_motors_control_u3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u3.out(0,1)->[Main.motors.control_u3.out(0,1)] and Main.motors.control_u3.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u3.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u3.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u3_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u3.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u3
            // **** Start non-nested deferred initialize for Main.motors.control_u4
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u4.out.
                // Iterate over range Main.motors.control_u4.out(0,1)->[Main.motors.control_u4.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u4_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u4_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u4_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u4.out(0,1)->[Main.motors.control_u4.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u4 triggers 1 downstream reactions
                        // through port Main.motors.control_u4.out.
                        main_motors_control_u4_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u4, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u4.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u4_self[src_runtime]->base.allocations); 
                        main_motors_control_u4_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u4.out(0,1)->[Main.motors.control_u4.out(0,1)] and Main.motors.control_u4.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u4.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u4.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u4_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u4.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u4
            // **** Start non-nested deferred initialize for Main.motors.control_u5
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u5.out.
                // Iterate over range Main.motors.control_u5.out(0,1)->[Main.motors.control_u5.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u5_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u5_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u5_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u5.out(0,1)->[Main.motors.control_u5.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u5 triggers 1 downstream reactions
                        // through port Main.motors.control_u5.out.
                        main_motors_control_u5_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u5, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u5.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u5_self[src_runtime]->base.allocations); 
                        main_motors_control_u5_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u5.out(0,1)->[Main.motors.control_u5.out(0,1)] and Main.motors.control_u5.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u5.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u5.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u5_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u5.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u5
            // **** Start non-nested deferred initialize for Main.motors.control_u6
            {
            
                // For reference counting, set num_destinations for port Main.motors.control_u6.out.
                // Iterate over range Main.motors.control_u6.out(0,1)->[Main.motors.control_u6.out(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    main_motors_control_u6_self[src_runtime]->_lf_out._base.num_destinations = 1;
                    main_motors_control_u6_self[src_runtime]->_lf_out._base.source_reactor = (self_base_t*)main_motors_control_u6_self[src_runtime];
                }
                {
                    int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                    // Iterate over range Main.motors.control_u6.out(0,1)->[Main.motors.control_u6.out(0,1)].
                    {
                        int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                        int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                        int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Reaction 0 of Main.motors.control_u6 triggers 1 downstream reactions
                        // through port Main.motors.control_u6.out.
                        main_motors_control_u6_self[src_runtime]->_lf__reaction_0.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 0 of Main.motors.control_u6, allocate an
                        // array of trigger pointers for downstream reactions through port Main.motors.control_u6.out
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_motors_control_u6_self[src_runtime]->base.allocations); 
                        main_motors_control_u6_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime]++] = trigger_array;
                    }
                    for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                    // Iterate over ranges Main.motors.control_u6.out(0,1)->[Main.motors.control_u6.out(0,1)] and Main.motors.control_u6.out(0,1).
                    {
                        int src_runtime = 0; // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = 0; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = 0; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Iterate over range Main.motors.control_u6.out(0,1).
                        {
                            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                            // Port Main.motors.control_u6.out has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_motors_control_u6_self[src_runtime]->_lf__reaction_0.triggers[triggers_index[src_runtime] + src_channel][0] = &main_motors_self[dst_runtime]->_lf_control_u6.out_trigger;
                        }
                    }
                }
            
            }
            // **** End of non-nested deferred initialize for Main.motors.control_u6
        }
        // **** End of non-nested deferred initialize for Main.motors
        // **** Start non-nested deferred initialize for Main.home
        {
        
            // For reference counting, set num_destinations for port Main.home.motor_speed.
            // Iterate over range Main.home.motor_speed(0,7)->[Main.home.motor_speed(0,7)].
            {
                int range_start[] =  { 0, 0 };
                int range_radixes[] = { 7, 1 };
                int permutation[] = { 0, 1 };
                mixed_radix_int_t range_mr = {
                    2,
                    range_start,
                    range_radixes,
                    permutation
                };
                for (int range_count = 0; range_count < 0 + 7; range_count++) {
                    int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = range_mr.digits[0]; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = range_mr.digits[1]; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    main_home_self[src_runtime]->_lf_motor_speed[src_channel]._base.num_destinations = 1;
                    main_home_self[src_runtime]->_lf_motor_speed[src_channel]._base.source_reactor = (self_base_t*)main_home_self[src_runtime];
                    mixed_radix_incr(&range_mr);
                }
            }
            // For reference counting, set num_destinations for port Main.home.is_home.
            // Iterate over range Main.home.is_home(0,1)->[Main.home.is_home(0,1)].
            {
                int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                main_home_self[src_runtime]->_lf_is_home._base.num_destinations = 1;
                main_home_self[src_runtime]->_lf_is_home._base.source_reactor = (self_base_t*)main_home_self[src_runtime];
            }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
                // Iterate over range Main.home.motor_speed(0,7)->[Main.home.motor_speed(0,7)].
                {
                    int range_start[] =  { 0, 0 };
                    int range_radixes[] = { 7, 1 };
                    int permutation[] = { 0, 1 };
                    mixed_radix_int_t range_mr = {
                        2,
                        range_start,
                        range_radixes,
                        permutation
                    };
                    for (int range_count = 0; range_count < 0 + 7; range_count++) {
                        int src_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                        SUPPRESS_UNUSED_WARNING(src_runtime);
                        int src_channel = range_mr.digits[0]; // Channel index.
                        SUPPRESS_UNUSED_WARNING(src_channel);
                        int src_bank = range_mr.digits[1]; // Bank index.
                        SUPPRESS_UNUSED_WARNING(src_bank);
                        // Reaction 1 of Main.home triggers 1 downstream reactions
                        // through port Main.home.motor_speed.
                        main_home_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                        // For reaction 1 of Main.home, allocate an
                        // array of trigger pointers for downstream reactions through port Main.home.motor_speed
                        trigger_t** trigger_array = (trigger_t**)lf_allocate(
                                1, sizeof(trigger_t*),
                                &main_home_self[src_runtime]->base.allocations); 
                        main_home_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                        mixed_radix_incr(&range_mr);
                    }
                }
                // Iterate over range Main.home.is_home(0,1)->[Main.home.is_home(0,1)].
                {
                    int src_runtime = 0; SUPPRESS_UNUSED_WARNING(src_runtime); // Runtime index.
                    int src_channel = 0; SUPPRESS_UNUSED_WARNING(src_channel); // Channel index.
                    int src_bank = 0; SUPPRESS_UNUSED_WARNING(src_bank); // Bank index.
                    int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                    // Reaction 1 of Main.home triggers 1 downstream reactions
                    // through port Main.home.is_home.
                    main_home_self[src_runtime]->_lf__reaction_1.triggered_sizes[triggers_index[src_runtime]] = 1;
                    // For reaction 1 of Main.home, allocate an
                    // array of trigger pointers for downstream reactions through port Main.home.is_home
                    trigger_t** trigger_array = (trigger_t**)lf_allocate(
                            1, sizeof(trigger_t*),
                            &main_home_self[src_runtime]->base.allocations); 
                    main_home_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime]++] = trigger_array;
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 0;
                // Iterate over ranges Main.home.motor_speed(0,7)->[Main.home.motor_speed(0,7)] and Main.home.motor_speed(0,7).
                {
                    int src_start[] =  { 0, 0 };
                    int src_value[] =  { 0, 0 }; // Will be incremented.
                    int src_radixes[] = { 7, 1 };
                    int src_permutation[] = { 0, 1 };
                    mixed_radix_int_t src_range_mr = {
                        2,
                        src_value,
                        src_radixes,
                        src_permutation
                    };
                    // Iterate over range Main.home.motor_speed(0,7).
                    {
                        int range_start[] =  { 0, 0 };
                        int range_radixes[] = { 7, 1 };
                        int permutation[] = { 0, 1 };
                        mixed_radix_int_t range_mr = {
                            2,
                            range_start,
                            range_radixes,
                            permutation
                        };
                        for (int range_count = 0; range_count < 0 + 7; range_count++) {
                            int dst_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(dst_runtime);
                            int dst_channel = range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(dst_channel);
                            int dst_bank = range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(dst_bank);
                            int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                            SUPPRESS_UNUSED_WARNING(src_runtime);
                            int src_channel = src_range_mr.digits[0]; // Channel index.
                            SUPPRESS_UNUSED_WARNING(src_channel);
                            int src_bank = src_range_mr.digits[1]; // Bank index.
                            SUPPRESS_UNUSED_WARNING(src_bank);
                            // Port Main.home.motor_speed has reactions in its parent's parent.
                            // Point to the trigger struct for those reactions.
                            main_home_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_main_self[dst_runtime]->_lf_home.motor_speed_trigger;
                            mixed_radix_incr(&src_range_mr);
                            if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                                // Start over with the source.
                                for (int i = 0; i < src_range_mr.size; i++) {
                                    src_range_mr.digits[i] = src_start[i];
                                }
                            }
                            mixed_radix_incr(&range_mr);
                        }
                    }
                }
                for (int i = 0; i < 1; i++) triggers_index[i] = 7;
                // Iterate over ranges Main.home.is_home(0,1)->[Main.home.is_home(0,1)] and Main.home.is_home(0,1).
                {
                    int src_runtime = 0; // Runtime index.
                    SUPPRESS_UNUSED_WARNING(src_runtime);
                    int src_channel = 0; // Channel index.
                    SUPPRESS_UNUSED_WARNING(src_channel);
                    int src_bank = 0; // Bank index.
                    SUPPRESS_UNUSED_WARNING(src_bank);
                    // Iterate over range Main.home.is_home(0,1).
                    {
                        int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
                        int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
                        int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
                        int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
                        // Port Main.home.is_home has reactions in its parent's parent.
                        // Point to the trigger struct for those reactions.
                        main_home_self[src_runtime]->_lf__reaction_1.triggers[triggers_index[src_runtime] + src_channel][0] = &main_main_self[dst_runtime]->_lf_home.is_home_trigger;
                    }
                }
            }
        
        }
        // **** End of non-nested deferred initialize for Main.home
        // **** Start non-nested deferred initialize for Main.ros_controller
        {
        
            for (int index486184027c8990b = 0; index486184027c8990b < 7; index486184027c8990b++) { main_ros_controller_self[0]->_lf_target_pos[index486184027c8990b]._base.source_reactor = (self_base_t*)main_ros_controller_self[0]; }
            {
                int triggers_index[1] = { 0 }; // Number of bank members with the reaction.
            }
        
        }
        // **** End of non-nested deferred initialize for Main.ros_controller
    }
    // **** End of non-nested deferred initialize for Main
    // Connect inputs and outputs for reactor Main.
    // Connect inputs and outputs for reactor Main.qdec.
    // Connect Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)] to port Main.qdec.reset_qdec(0,1)
    // Iterate over ranges Main.qdec.reset_qdec(0,1)->[Main.qdec.reset_qdec(0,1)] and Main.qdec.reset_qdec(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.qdec.reset_qdec(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_qdec_self[dst_runtime]->_lf_reset_qdec = (_qdec_reset_qdec_t*)&main_main_self[src_runtime]->_lf_qdec.reset_qdec;
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.motors.control_u0.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] and Main.motors.control_u0.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u0.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u0_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.ros_controller.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] and Main.ros_controller.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] to port Main.home.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(0,1)->[Main.motors.control_u0.current_pos(0,1), Main.ros_controller.current_pos(0,1), Main.home.current_pos(0,1)] and Main.home.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] to port Main.motors.control_u1.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] and Main.motors.control_u1.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u1.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u1_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] to port Main.ros_controller.current_pos(1,1)
    // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] and Main.ros_controller.current_pos(1,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(1,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] to port Main.home.current_pos(1,1)
    // Iterate over ranges Main.qdec.qdec_out(1,1)->[Main.motors.control_u1.current_pos(0,1), Main.ros_controller.current_pos(1,1), Main.home.current_pos(1,1)] and Main.home.current_pos(1,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(1,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 1; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] to port Main.motors.control_u2.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] and Main.motors.control_u2.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u2.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u2_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] to port Main.home.current_pos(2,1)
    // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] and Main.home.current_pos(2,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(2,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 2; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] to port Main.ros_controller.current_pos(2,1)
    // Iterate over ranges Main.qdec.qdec_out(2,1)->[Main.motors.control_u2.current_pos(0,1), Main.home.current_pos(2,1), Main.ros_controller.current_pos(2,1)] and Main.ros_controller.current_pos(2,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(2,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 2; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] to port Main.motors.control_u3.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] and Main.motors.control_u3.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u3.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u3_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] to port Main.ros_controller.current_pos(3,1)
    // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] and Main.ros_controller.current_pos(3,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(3,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 3; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] to port Main.home.current_pos(3,1)
    // Iterate over ranges Main.qdec.qdec_out(3,1)->[Main.motors.control_u3.current_pos(0,1), Main.ros_controller.current_pos(3,1), Main.home.current_pos(3,1)] and Main.home.current_pos(3,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(3,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 3; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] to port Main.motors.control_u4.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] and Main.motors.control_u4.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u4.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u4_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] to port Main.home.current_pos(4,1)
    // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] and Main.home.current_pos(4,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(4,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 4; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] to port Main.ros_controller.current_pos(4,1)
    // Iterate over ranges Main.qdec.qdec_out(4,1)->[Main.motors.control_u4.current_pos(0,1), Main.home.current_pos(4,1), Main.ros_controller.current_pos(4,1)] and Main.ros_controller.current_pos(4,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(4,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 4; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] to port Main.motors.control_u5.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] and Main.motors.control_u5.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u5.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u5_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] to port Main.ros_controller.current_pos(5,1)
    // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] and Main.ros_controller.current_pos(5,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(5,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 5; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] to port Main.home.current_pos(5,1)
    // Iterate over ranges Main.qdec.qdec_out(5,1)->[Main.motors.control_u5.current_pos(0,1), Main.ros_controller.current_pos(5,1), Main.home.current_pos(5,1)] and Main.home.current_pos(5,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(5,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 5; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] to port Main.ros_controller.current_pos(6,1)
    // Iterate over ranges Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] and Main.ros_controller.current_pos(6,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 6; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.ros_controller.current_pos(6,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 6; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_ros_controller_self[dst_runtime]->_lf_current_pos[dst_channel] = (_ros_interface_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] to port Main.home.current_pos(6,1)
    // Iterate over ranges Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] and Main.home.current_pos(6,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 6; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.current_pos(6,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 6; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_home_self[dst_runtime]->_lf_current_pos[dst_channel] = (_home_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] to port Main.motors.control_u6.current_pos(0,1)
    // Iterate over ranges Main.qdec.qdec_out(6,1)->[Main.ros_controller.current_pos(6,1), Main.home.current_pos(6,1), Main.motors.control_u6.current_pos(0,1)] and Main.motors.control_u6.current_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 6; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u6.current_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u6_self[dst_runtime]->_lf_current_pos = (_pidcontroller_current_pos_t*)&main_qdec_self[src_runtime]->_lf_qdec_out[src_channel];
        }
    }
    // Connect Main.qdec.sea_out(0,7)->[Main.home.sea_pos(0,7)] to port Main.home.sea_pos(0,7)
    // Iterate over ranges Main.qdec.sea_out(0,7)->[Main.home.sea_pos(0,7)] and Main.home.sea_pos(0,7).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 7, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.home.sea_pos(0,7).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 7, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 7; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_home_self[dst_runtime]->_lf_sea_pos[dst_channel] = (_home_sea_pos_t*)&main_qdec_self[src_runtime]->_lf_sea_out[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect inputs and outputs for reactor Main.motors.
    // Connect Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)] to port Main.motors.target_sel(0,7)
    // Iterate over ranges Main.motors.target_sel(0,7)->[Main.motors.target_sel(0,7)] and Main.motors.target_sel(0,7).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 7, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.motors.target_sel(0,7).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 7, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 7; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_motors_self[dst_runtime]->_lf_target_sel[dst_channel] = (_motordriver_target_sel_t*)main_main_self[src_runtime]->_lf_motors.target_sel[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)] to port Main.motors.target_speed(0,7)
    // Iterate over ranges Main.motors.target_speed(0,7)->[Main.motors.target_speed(0,7)] and Main.motors.target_speed(0,7).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 7, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.motors.target_speed(0,7).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 7, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 7; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_motors_self[dst_runtime]->_lf_target_speed[dst_channel] = (_motordriver_target_speed_t*)main_main_self[src_runtime]->_lf_motors.target_speed[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Main.motors.target_pos(0,1)->[Main.motors.control_u0.target_pos(0,1)] to port Main.motors.control_u0.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(0,1)->[Main.motors.control_u0.target_pos(0,1)] and Main.motors.control_u0.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u0.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u0_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(1,1)->[Main.motors.control_u1.target_pos(0,1)] to port Main.motors.control_u1.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(1,1)->[Main.motors.control_u1.target_pos(0,1)] and Main.motors.control_u1.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 1; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u1.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u1_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(2,1)->[Main.motors.control_u2.target_pos(0,1)] to port Main.motors.control_u2.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(2,1)->[Main.motors.control_u2.target_pos(0,1)] and Main.motors.control_u2.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 2; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u2.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u2_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(3,1)->[Main.motors.control_u3.target_pos(0,1)] to port Main.motors.control_u3.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(3,1)->[Main.motors.control_u3.target_pos(0,1)] and Main.motors.control_u3.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 3; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u3.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u3_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(4,1)->[Main.motors.control_u4.target_pos(0,1)] to port Main.motors.control_u4.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(4,1)->[Main.motors.control_u4.target_pos(0,1)] and Main.motors.control_u4.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 4; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u4.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u4_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(5,1)->[Main.motors.control_u5.target_pos(0,1)] to port Main.motors.control_u5.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(5,1)->[Main.motors.control_u5.target_pos(0,1)] and Main.motors.control_u5.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 5; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u5.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u5_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect Main.motors.target_pos(6,1)->[Main.motors.control_u6.target_pos(0,1)] to port Main.motors.control_u6.target_pos(0,1)
    // Iterate over ranges Main.motors.target_pos(6,1)->[Main.motors.control_u6.target_pos(0,1)] and Main.motors.control_u6.target_pos(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 6; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u6.target_pos(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_control_u6_self[dst_runtime]->_lf_target_pos = (_pidcontroller_target_pos_t*)main_main_self[src_runtime]->_lf_motors.target_pos[src_channel];
        }
    }
    // Connect inputs and outputs for reactor Main.motors.usm.
    // Connect Main.motors.usm.set_speed_0(0,1)->[Main.motors.usm.set_speed_0(0,1)] to port Main.motors.usm.set_speed_0(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_0(0,1)->[Main.motors.usm.set_speed_0(0,1)] and Main.motors.usm.set_speed_0(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_0(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_0 = (_usm_set_speed_0_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_0;
        }
    }
    // Connect Main.motors.usm.set_speed_1(0,1)->[Main.motors.usm.set_speed_1(0,1)] to port Main.motors.usm.set_speed_1(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_1(0,1)->[Main.motors.usm.set_speed_1(0,1)] and Main.motors.usm.set_speed_1(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_1(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_1 = (_usm_set_speed_1_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_1;
        }
    }
    // Connect Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)] to port Main.motors.usm.set_speed_2(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_2(0,1)->[Main.motors.usm.set_speed_2(0,1)] and Main.motors.usm.set_speed_2(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_2(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_2 = (_usm_set_speed_2_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_2;
        }
    }
    // Connect Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)] to port Main.motors.usm.set_speed_3(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_3(0,1)->[Main.motors.usm.set_speed_3(0,1)] and Main.motors.usm.set_speed_3(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_3(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_3 = (_usm_set_speed_3_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_3;
        }
    }
    // Connect Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)] to port Main.motors.usm.set_speed_4(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_4(0,1)->[Main.motors.usm.set_speed_4(0,1)] and Main.motors.usm.set_speed_4(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_4(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_4 = (_usm_set_speed_4_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_4;
        }
    }
    // Connect Main.motors.usm.set_speed_5(0,1)->[Main.motors.usm.set_speed_5(0,1)] to port Main.motors.usm.set_speed_5(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_5(0,1)->[Main.motors.usm.set_speed_5(0,1)] and Main.motors.usm.set_speed_5(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_5(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_5 = (_usm_set_speed_5_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_5;
        }
    }
    // Connect Main.motors.usm.set_speed_6(0,1)->[Main.motors.usm.set_speed_6(0,1)] to port Main.motors.usm.set_speed_6(0,1)
    // Iterate over ranges Main.motors.usm.set_speed_6(0,1)->[Main.motors.usm.set_speed_6(0,1)] and Main.motors.usm.set_speed_6(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.usm.set_speed_6(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_usm_self[dst_runtime]->_lf_set_speed_6 = (_usm_set_speed_6_t*)&main_motors_self[src_runtime]->_lf_usm.set_speed_6;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u0.
    // Connect Main.motors.control_u0.out(0,1)->[Main.motors.control_u0.out(0,1)] to port Main.motors.control_u0.out(0,1)
    // Iterate over ranges Main.motors.control_u0.out(0,1)->[Main.motors.control_u0.out(0,1)] and Main.motors.control_u0.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u0.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u0.out = (_pidcontroller_out_t*)&main_motors_control_u0_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u1.
    // Connect Main.motors.control_u1.out(0,1)->[Main.motors.control_u1.out(0,1)] to port Main.motors.control_u1.out(0,1)
    // Iterate over ranges Main.motors.control_u1.out(0,1)->[Main.motors.control_u1.out(0,1)] and Main.motors.control_u1.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u1.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u1.out = (_pidcontroller_out_t*)&main_motors_control_u1_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u2.
    // Connect Main.motors.control_u2.out(0,1)->[Main.motors.control_u2.out(0,1)] to port Main.motors.control_u2.out(0,1)
    // Iterate over ranges Main.motors.control_u2.out(0,1)->[Main.motors.control_u2.out(0,1)] and Main.motors.control_u2.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u2.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u2.out = (_pidcontroller_out_t*)&main_motors_control_u2_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u3.
    // Connect Main.motors.control_u3.out(0,1)->[Main.motors.control_u3.out(0,1)] to port Main.motors.control_u3.out(0,1)
    // Iterate over ranges Main.motors.control_u3.out(0,1)->[Main.motors.control_u3.out(0,1)] and Main.motors.control_u3.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u3.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u3.out = (_pidcontroller_out_t*)&main_motors_control_u3_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u4.
    // Connect Main.motors.control_u4.out(0,1)->[Main.motors.control_u4.out(0,1)] to port Main.motors.control_u4.out(0,1)
    // Iterate over ranges Main.motors.control_u4.out(0,1)->[Main.motors.control_u4.out(0,1)] and Main.motors.control_u4.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u4.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u4.out = (_pidcontroller_out_t*)&main_motors_control_u4_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u5.
    // Connect Main.motors.control_u5.out(0,1)->[Main.motors.control_u5.out(0,1)] to port Main.motors.control_u5.out(0,1)
    // Iterate over ranges Main.motors.control_u5.out(0,1)->[Main.motors.control_u5.out(0,1)] and Main.motors.control_u5.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u5.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u5.out = (_pidcontroller_out_t*)&main_motors_control_u5_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.motors.control_u6.
    // Connect Main.motors.control_u6.out(0,1)->[Main.motors.control_u6.out(0,1)] to port Main.motors.control_u6.out(0,1)
    // Iterate over ranges Main.motors.control_u6.out(0,1)->[Main.motors.control_u6.out(0,1)] and Main.motors.control_u6.out(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.motors.control_u6.out(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_motors_self[dst_runtime]->_lf_control_u6.out = (_pidcontroller_out_t*)&main_motors_control_u6_self[src_runtime]->_lf_out;
        }
    }
    // Connect inputs and outputs for reactor Main.home.
    // Connect Main.home.motor_speed(0,7)->[Main.home.motor_speed(0,7)] to port Main.home.motor_speed(0,7)
    // Iterate over ranges Main.home.motor_speed(0,7)->[Main.home.motor_speed(0,7)] and Main.home.motor_speed(0,7).
    {
        int src_start[] =  { 0, 0 };
        int src_value[] =  { 0, 0 }; // Will be incremented.
        int src_radixes[] = { 7, 1 };
        int src_permutation[] = { 0, 1 };
        mixed_radix_int_t src_range_mr = {
            2,
            src_value,
            src_radixes,
            src_permutation
        };
        // Iterate over range Main.home.motor_speed(0,7).
        {
            int range_start[] =  { 0, 0 };
            int range_radixes[] = { 7, 1 };
            int permutation[] = { 0, 1 };
            mixed_radix_int_t range_mr = {
                2,
                range_start,
                range_radixes,
                permutation
            };
            for (int range_count = 0; range_count < 0 + 7; range_count++) {
                int dst_runtime = mixed_radix_parent(&range_mr, 2); // Runtime index.
                SUPPRESS_UNUSED_WARNING(dst_runtime);
                int dst_channel = range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(dst_channel);
                int dst_bank = range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(dst_bank);
                int src_runtime = mixed_radix_parent(&src_range_mr, 1); // Runtime index.
                SUPPRESS_UNUSED_WARNING(src_runtime);
                int src_channel = src_range_mr.digits[0]; // Channel index.
                SUPPRESS_UNUSED_WARNING(src_channel);
                int src_bank = src_range_mr.digits[1]; // Bank index.
                SUPPRESS_UNUSED_WARNING(src_bank);
                main_main_self[dst_runtime]->_lf_home.motor_speed[dst_channel] = (_home_motor_speed_t*)&main_home_self[src_runtime]->_lf_motor_speed[src_channel];
                mixed_radix_incr(&src_range_mr);
                if (mixed_radix_to_int(&src_range_mr) >= 0 + 7) {
                    // Start over with the source.
                    for (int i = 0; i < src_range_mr.size; i++) {
                        src_range_mr.digits[i] = src_start[i];
                    }
                }
                mixed_radix_incr(&range_mr);
            }
        }
    }
    // Connect Main.home.is_home(0,1)->[Main.home.is_home(0,1)] to port Main.home.is_home(0,1)
    // Iterate over ranges Main.home.is_home(0,1)->[Main.home.is_home(0,1)] and Main.home.is_home(0,1).
    {
        int src_runtime = 0; // Runtime index.
        SUPPRESS_UNUSED_WARNING(src_runtime);
        int src_channel = 0; // Channel index.
        SUPPRESS_UNUSED_WARNING(src_channel);
        int src_bank = 0; // Bank index.
        SUPPRESS_UNUSED_WARNING(src_bank);
        // Iterate over range Main.home.is_home(0,1).
        {
            int dst_runtime = 0; SUPPRESS_UNUSED_WARNING(dst_runtime); // Runtime index.
            int dst_channel = 0; SUPPRESS_UNUSED_WARNING(dst_channel); // Channel index.
            int dst_bank = 0; SUPPRESS_UNUSED_WARNING(dst_bank); // Bank index.
            int range_count = 0; SUPPRESS_UNUSED_WARNING(range_count);
            main_main_self[dst_runtime]->_lf_home.is_home = (_home_is_home_t*)&main_home_self[src_runtime]->_lf_is_home;
        }
    }
    // Connect inputs and outputs for reactor Main.ros_controller.
    
    {
    }
    {
        {
        }
        {
        }
        {
        }
        {
        }
        {
        }
        {
        }
        {
        }
        {
        }
        // Add port Main.motors.usm.set_speed_0 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[0 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_0.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[0 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_0.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_1 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[1 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_1.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[1 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_1.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_2 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[2 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_2.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[2 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_2.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_3 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[3 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_3.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[3 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_3.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_4 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[4 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_4.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[4 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_4.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_5 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[5 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_5.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[5 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_5.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        // Add port Main.motors.usm.set_speed_6 to array of is_present fields.
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                {
                    envs[main_main].is_present_fields[6 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_6.is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[6 + (0) * 1 + count] = &main_motors_self[0]->_lf_usm.set_speed_6.intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u0.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 7 + count] = &main_motors_control_u0_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u0.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 7 + count] = &main_motors_control_u0_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u1.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 8 + count] = &main_motors_control_u1_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u1.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 8 + count] = &main_motors_control_u1_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u2.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 9 + count] = &main_motors_control_u2_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u2.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 9 + count] = &main_motors_control_u2_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u3.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 10 + count] = &main_motors_control_u3_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u3.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 10 + count] = &main_motors_control_u3_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u4.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 11 + count] = &main_motors_control_u4_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u4.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 11 + count] = &main_motors_control_u4_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u5.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 12 + count] = &main_motors_control_u5_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u5.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 12 + count] = &main_motors_control_u5_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
        {
            int count = 0; SUPPRESS_UNUSED_WARNING(count);
            {
                // Add output port Main.motors.control_u6.out to array of is_present fields.
                envs[main_main].is_present_fields[(0) * 1 + 13 + count] = &main_motors_control_u6_self[0]->_lf_out.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.motors.control_u6.out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 1 + 13 + count] = &main_motors_control_u6_self[0]->_lf_out.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    {
    }
    {
    }
    // Add port Main.qdec.reset_qdec to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                envs[main_main].is_present_fields[14 + (0) * 1 + count] = &main_main_self[0]->_lf_qdec.reset_qdec.is_present;
                #ifdef FEDERATED_DECENTRALIZED
                envs[main_main]._lf_intended_tag_fields[14 + (0) * 1 + count] = &main_main_self[0]->_lf_qdec.reset_qdec.intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    // Add port Main.motors.target_sel to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                // Port Main.motors.target_sel is a multiport. Iterate over its channels.
                for (int main_motors_target_sel_c = 0; main_motors_target_sel_c < 7; main_motors_target_sel_c++) {
                    envs[main_main].is_present_fields[15 + (0) * 7 + count] = &main_main_self[0]->_lf_motors.target_sel[main_motors_target_sel_c]->is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[15 + (0) * 7 + count] = &main_main_self[0]->_lf_motors.target_sel[main_motors_target_sel_c]->intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    // Add port Main.motors.target_speed to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                // Port Main.motors.target_speed is a multiport. Iterate over its channels.
                for (int main_motors_target_speed_c = 0; main_motors_target_speed_c < 7; main_motors_target_speed_c++) {
                    envs[main_main].is_present_fields[22 + (0) * 7 + count] = &main_main_self[0]->_lf_motors.target_speed[main_motors_target_speed_c]->is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[22 + (0) * 7 + count] = &main_main_self[0]->_lf_motors.target_speed[main_motors_target_speed_c]->intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    // Add port Main.motors.target_pos to array of is_present fields.
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            {
                // Port Main.motors.target_pos is a multiport. Iterate over its channels.
                for (int main_motors_target_pos_c = 0; main_motors_target_pos_c < 7; main_motors_target_pos_c++) {
                    envs[main_main].is_present_fields[29 + (0) * 7 + count] = &main_main_self[0]->_lf_motors.target_pos[main_motors_target_pos_c]->is_present;
                    #ifdef FEDERATED_DECENTRALIZED
                    envs[main_main]._lf_intended_tag_fields[29 + (0) * 7 + count] = &main_main_self[0]->_lf_motors.target_pos[main_motors_target_pos_c]->intended_tag;
                    #endif // FEDERATED_DECENTRALIZED
                    count++;
                }
            }
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port Main.qdec.qdec_out to array of is_present fields.
            // Port Main.qdec.qdec_out is a multiport. Iterate over its channels.
            for (int main_qdec_qdec_out_c = 0; main_qdec_qdec_out_c < 7; main_qdec_qdec_out_c++) {
                envs[main_main].is_present_fields[(0) * 14 + 36 + count] = &main_qdec_self[0]->_lf_qdec_out[main_qdec_qdec_out_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.qdec.qdec_out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 14 + 36 + count] = &main_qdec_self[0]->_lf_qdec_out[main_qdec_qdec_out_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
            // Add output port Main.qdec.sea_out to array of is_present fields.
            // Port Main.qdec.sea_out is a multiport. Iterate over its channels.
            for (int main_qdec_sea_out_c = 0; main_qdec_sea_out_c < 7; main_qdec_sea_out_c++) {
                envs[main_main].is_present_fields[(0) * 14 + 36 + count] = &main_qdec_self[0]->_lf_sea_out[main_qdec_sea_out_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.qdec.sea_out to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 14 + 36 + count] = &main_qdec_self[0]->_lf_sea_out[main_qdec_sea_out_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port Main.home.motor_speed to array of is_present fields.
            // Port Main.home.motor_speed is a multiport. Iterate over its channels.
            for (int main_home_motor_speed_c = 0; main_home_motor_speed_c < 7; main_home_motor_speed_c++) {
                envs[main_main].is_present_fields[(0) * 8 + 50 + count] = &main_home_self[0]->_lf_motor_speed[main_home_motor_speed_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.home.motor_speed to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 8 + 50 + count] = &main_home_self[0]->_lf_motor_speed[main_home_motor_speed_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
            // Add output port Main.home.is_home to array of is_present fields.
            envs[main_main].is_present_fields[(0) * 8 + 50 + count] = &main_home_self[0]->_lf_is_home.is_present;
            #ifdef FEDERATED_DECENTRALIZED
            // Add output port Main.home.is_home to array of intended_tag fields.
            envs[main_main]._lf_intended_tag_fields[(0) * 8 + 50 + count] = &main_home_self[0]->_lf_is_home.intended_tag;
            #endif // FEDERATED_DECENTRALIZED
            count++;
        }
    }
    {
        int count = 0; SUPPRESS_UNUSED_WARNING(count);
        {
            // Add output port Main.ros_controller.target_pos to array of is_present fields.
            // Port Main.ros_controller.target_pos is a multiport. Iterate over its channels.
            for (int main_ros_controller_target_pos_c = 0; main_ros_controller_target_pos_c < 7; main_ros_controller_target_pos_c++) {
                envs[main_main].is_present_fields[(0) * 7 + 58 + count] = &main_ros_controller_self[0]->_lf_target_pos[main_ros_controller_target_pos_c].is_present;
                #ifdef FEDERATED_DECENTRALIZED
                // Add output port Main.ros_controller.target_pos to array of intended_tag fields.
                envs[main_main]._lf_intended_tag_fields[(0) * 7 + 58 + count] = &main_ros_controller_self[0]->_lf_target_pos[main_ros_controller_target_pos_c].intended_tag;
                #endif // FEDERATED_DECENTRALIZED
                count++;
            }
        }
    }
    
    // Set reaction priorities for ReactorInstance Main
    {
        // index is the OR of level 0 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
        // index is the OR of level 1 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 1);
        // index is the OR of level 5 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 5);
        // index is the OR of level 6 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_3.index = lf_combine_deadline_and_level(9223372036854775807, 6);
        // index is the OR of level 7 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_4.index = lf_combine_deadline_and_level(9223372036854775807, 7);
        // index is the OR of level 8 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_5.index = lf_combine_deadline_and_level(9223372036854775807, 8);
        // index is the OR of level 9 and 
        // deadline 9223372036854775807 shifted left 16 bits.
        main_main_self[0]->_lf__reaction_6.index = lf_combine_deadline_and_level(9223372036854775807, 9);
    
        // Set reaction priorities for ReactorInstance Main.qdec
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 2 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 2);
            // index is the OR of level 3 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 3);
            // index is the OR of level 4 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_qdec_self[0]->_lf__reaction_3.index = lf_combine_deadline_and_level(9223372036854775807, 4);
        }
    
    
        // Set reaction priorities for ReactorInstance Main.motors
        {
            // index is the OR of level 11 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_motors_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 11);
            // index is the OR of level 12 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_motors_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 12);
            // index is the OR of level 13 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_motors_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 13);
        
            // Set reaction priorities for ReactorInstance Main.motors.usm
            {
                // index is the OR of level 0 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_usm_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
                // index is the OR of level 14 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_usm_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 14);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u0
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u0_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u1
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u1_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u2
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u2_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u3
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u3_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u4
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u4_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u5
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u5_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        
            // Set reaction priorities for ReactorInstance Main.motors.control_u6
            {
                // index is the OR of level 10 and 
                // deadline 9223372036854775807 shifted left 16 bits.
                main_motors_control_u6_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 10);
            }
        
        }
    
    
        // Set reaction priorities for ReactorInstance Main.home
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_home_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 4 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_home_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 4);
        }
    
    
        // Set reaction priorities for ReactorInstance Main.ros_controller
        {
            // index is the OR of level 0 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_ros_controller_self[0]->_lf__reaction_0.index = lf_combine_deadline_and_level(9223372036854775807, 0);
            // index is the OR of level 4 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_ros_controller_self[0]->_lf__reaction_1.index = lf_combine_deadline_and_level(9223372036854775807, 4);
            // index is the OR of level 5 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_ros_controller_self[0]->_lf__reaction_2.index = lf_combine_deadline_and_level(9223372036854775807, 5);
            // index is the OR of level 6 and 
            // deadline 9223372036854775807 shifted left 16 bits.
            main_ros_controller_self[0]->_lf__reaction_3.index = lf_combine_deadline_and_level(9223372036854775807, 6);
        }
    
    }
    

    #ifdef EXECUTABLE_PREAMBLE
    _lf_executable_preamble(&envs[0]);
    #endif
    #ifdef FEDERATED
    initialize_triggers_for_federate();
    #endif // FEDERATED
}
void logical_tag_complete(tag_t tag_to_send) {
 #ifdef FEDERATED_CENTRALIZED
     lf_latest_tag_confirmed(tag_to_send);
 #else
     (void) tag_to_send;
 #endif // FEDERATED_CENTRALIZED

}
#ifndef FEDERATED
void lf_terminate_execution(environment_t* env) {
    (void) env;
}
#endif
