target C {
  single-threaded: true,
  platform: {
    name: "STM32",
    board: "F446RE"
  },
  //files: ["/include_c/stm_comms.h", "/src_c/stm_comms.c"],
  cmake-include: ["/SerialCMakeLists.txt"]
}

preamble {=
  #include <stdio.h>
  #include "stm32f4xx_hal.h"
  //#include "stm32_startup.h"
  #include "main.h"
  #include "stm_comms.h"

  extern UART_HandleTypeDef huart1; // make sure these need to be defined here or not
  extern UART_HandleTypeDef huart2;
  extern UART_HandleTypeDef huart3;
  extern UART_HandleTypeDef huart4;
  extern UART_HandleTypeDef huart5;

  extern TIM_HandleTypeDef htim6; // used for timing loops

  =}

// Import and/or declare reactor classes.
main reactor {
  preamble {=

    uint8_t uart_rx_dma_buffer[UART_BUFFER_SIZE];
    uint8_t uart_rx_dma_copy_buffer[UART_BUFFER_SIZE];
    uint16_t uart_rx_last_pos = 0;

    static uint8_t pkt_buf[MAX_PACKET_SIZE];
    static uint8_t pkt_index = 0;
    static uint8_t pkt_length = 0;
    static enum { RX_IDLE, RX_GOT_START, RX_GOT_LEN } rx_state = RX_IDLE;
`


    void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size){
      //printf("In the HAL_UARTEx_RxEventCallback function! Got %d bytes.\n", Size);
      //handle_packet(uint8_t *packet, uint8_t len);

      printf("In the HAL_UARTEx_RxEventCallback function! Received packet (%d bytes): ", Size);

      handle_packet(uart_rx_dma_buffer, Size);

      HAL_UARTEx_ReceiveToIdle_DMA(&DMA_UART, uart_rx_dma_buffer, UART_BUFFER_SIZE);
    }

    // ------
    // Init functions
    // ------
    void uart_dma_start() {
        //__HAL_UART_ENABLE_IT(&DMA_UART, UART_IT_IDLE);
        HAL_UARTEx_ReceiveToIdle_DMA(&DMA_UART, uart_rx_dma_buffer, UART_BUFFER_SIZE);
        //HAL_UART_Receive_DMA(&DMA_UART, uart_rx_dma_buffer, UART_BUFFER_SIZE);
    }

    // ------
    // Receiving functions
    // ------

    void uart_dma_poll() {
      uint16_t pos = UART_BUFFER_SIZE - __HAL_DMA_GET_COUNTER(DMA_UART.hdmarx);
      
      //printf("Got pos: %d\n", pos);
      if (pos != uart_rx_last_pos) {
          if (pos > uart_rx_last_pos) {
              process_uart_data(&uart_rx_dma_buffer[uart_rx_last_pos], pos - uart_rx_last_pos);
          } else {
              // Wrapped around
              process_uart_data(&uart_rx_dma_buffer[uart_rx_last_pos], UART_BUFFER_SIZE - uart_rx_last_pos);
              process_uart_data(&uart_rx_dma_buffer[0], pos);
          }
          uart_rx_last_pos = pos;
      }
    }

    void handle_packet(uint8_t *packet, uint8_t len) {
      uint8_t type = packet[2];

      switch (type) {
          case PKT_TYPE_PING:
              send_packet(PKT_TYPE_PING, NULL, 0); // Echo back
              break;

          case PKT_TYPE_DATA:
              uint8_t *data = &packet[3]; // After start, len, type
              size_t data_len = len - 4; // Remove start, len, type, checksum
              parse_packet_data(data, data_len);
              break;
      }
    }

    // ------
    // Sending functions
    // ------

    void send_packet(PacketType type, uint8_t *data, uint8_t len) {
      uint8_t tx_buf[MAX_PACKET_SIZE];
      uint8_t index = 0;
      uint8_t checksum = 0;

      tx_buf[index++] = PACKET_START_BYTE;
      tx_buf[index++] = len + 1; // type + data
      tx_buf[index++] = type;

      for (uint8_t i = 0; i < len; ++i)
          tx_buf[index++] = data[i];

      for (uint8_t i = 1; i < index; ++i)
          checksum ^= tx_buf[i];

      tx_buf[index++] = checksum;

      //printf("About to send tx_buf of: \r\n");
      //for (int i = 0; i<index; i++) printf("%02X ", tx_buf[i]);
      //printf("\r\n");
      HAL_UART_Transmit_DMA(&DMA_UART, tx_buf, index);
      //HAL_UART_Transmit(&DMA_UART, tx_buf, index, HAL_MAX_DELAY);
    }

    
    int stm32_init(void){
      HAL_Init();

      SystemClock_Config();

      MX_GPIO_Init();
      MX_DMA_Init();
      MX_UART4_Init();
      MX_USART1_UART_Init();
      MX_USART3_UART_Init();
      MX_USART6_UART_Init();
      MX_TIM3_Init();
      MX_TIM4_Init();
      MX_TIM6_Init();
      HAL_TIM_Base_Start(&htim6); // added!
      MX_RTC_Init();
      MX_USART2_UART_Init();

      printf("\r\n");
      printf("~~~ STM32 START ~~~ \r\n");
      printf("\r\n");

      //HAL_START_DMA(); // not sure if needed
      //main();
      return 0;
    }

    void handle_transmit_packet(){

      // send the encoded packet down the UART line
      char buff[30] = "From the STM32";
      //memcpy(tx_buffer, buff, sizeof(buff));
      //printf("trying to send tx_buffer of size DMA_TX_BUFFER_SIZE(%d): %s\r\n", sizeof(tx_buffer), tx_buffer);
      HAL_UART_Transmit_DMA(&DMA_UART, buff, sizeof(buff));
    }


  =}
  
  timer sys_tick(0 ms, 10 ms)           // Main system clock we will use inside main
  timer switch_motor(0 ms, 1000 ms)     // Switch moto position state

  timer comms(0 ms, 2 ms)

  state counter: int = 0
  state counter_max: int = 100

  state start_time: time = 0

  reaction(startup) {=
    // Prep all GPIO values
    //MX_GPIO_Init();

    // Initialize the STM32 peripherals
    stm32_init();
    uart_dma_start();

    self->start_time = lf_time_physical();
  =}

  reaction(comms) {=
    // handle receiving from computer
    //uart_dma_poll();

    // handle writing back to comptuer
    self->counter++;
    if (self->counter_max < self->counter) self->counter = 0;
    
    int timestamp = HAL_GetTick();//(int)(lf_time_physical() - self->start_time) / 1000000;
    
    //printf("Loop timestamp: %d ms\r\n", (int)(lf_time_physical() - self->start_time) / 1000000);
    self->start_time = lf_time_physical();

    STM_Packet transmit_packet = {
        .behavior_mode = 0, 
        .positions = {0.1f, 0.2f, 0.3f, 0.4f, 0.5f, 0.6f, 0.7f},
        .velocities = {((float)self->counter) / 2000.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f, 0.0f},
        .sea_positions = {1.1f, 1.2f, 1.3f, 1.4f, 1.5f, 1.6f, 1.7f},
        .extra = {3.14},
        .time_stamp = HAL_GetTick()
    };


    //PacketType type, uint8_t *data, uint8_t len
    uint8_t tx_buff[100];
    encode_packet_to_bytes(&transmit_packet, tx_buff);
    //uint8_t num = sprintf(tx_buff, "%s", "look at this packet!\n");
    send_packet(PKT_TYPE_DATA, tx_buff, sizeof(STM_Packet));//MAX_PACKET_SIZE);

    

    =}
}
