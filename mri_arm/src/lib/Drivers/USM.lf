target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include <stdio.h>
  #include <stdlib.h>
  #include <math.h> // need for floating point abs, or fabsf()
  #include <../../../c_include/motor_config.h>

  #define PRINT_USM 0
  #define DO_DEBUG_PWM_SWEEP 0

  // only these two consts are needed if output pin is reliably 3.3V at 100% duty cycle.
  #define ARR_PERIOD 2000 //2000 //2000 //2000 //10000 would be great but still sawtooth-esque //65535 // 16-bit timer period for ARR (auto reload register)
  #define PWM_RPM_MAX 250.0 // 250 RPM
  #define PWM_RAD_PER_SEC_MAX 26.17993875 // 250 RPM = 26.1799... rad/s
  #define PWM_DEG_PER_SEC_MAX 1500.0 // 250 RPM = 1500 deg/s
  #define MSEC_TO_SEC 0.001

  // safety const
  #define USM_MAX_DUTY_CYCLE 0.20 //0.30 //0.06 //0.5 // only higher than 6% for PWM pin testing //0.06 // 6% duty cycle
  //#define USM_MIN_DUTY_CYCLE 0.0 // deadband to limit amount of jerky motion at small angular velocities
  #define USM_MIN_DUTY_CYCLE 0.00 // if below this amount, we don't expect the motors to be able to move smoothly on their own based on bench testing.

  // conversion for if inputs are in rad_per_sec
  #define RAD_PER_SEC_TO_RPM 9.549297
  #define RAD_PER_SEC_TO_DEG_PER_SEC 57.2958


  #define RPM_TO_DEG_PER_SEC 6.0
  // these two consts aren't needed if we can assume 3.3V is the max pin voltage. Make sure it's not a 5V output!
  //#define PWM_VOLTAGE_MAX 3.3 // voltage at [3.3V] 100% duty cycle
  //#define PWM_RPM_PER_VOLT 75.757576 // 250.0RPM / 3.3V based on tekceleo datasheet for WLG-75-R motors


=}

reactor USM {
  input[7] speed: float
  input force_disable_motor_pins: bool
  output[7] commanded_duty_cycle: float

  state _force_disable_motor_pins: bool = false

  //state force_disable_motor_pins
  preamble {=

    // for debugging
    long reference_tick_usm = 0; //HAL_GetTick();
    float debug_duty_cycle_sweep_time_interval = 2.0;
    float debug_duty_cycle_sweep_increment = 0.01; //0.0001;
    float debug_duty_cycle = 0.00;


    // PWM AND DUTY CYCLE FUNCTIONS
    // note that all of this assumes a max voltage of 3.3V! If it's actually different, these numbers are wrong.
    float apply_duty_cycle_limits(float duty_cycle){
      duty_cycle = fabsf(duty_cycle); // force it positive

      if (PRINT_USM)printf("Got duty cycle of %d%, or %d deg/s\r\n", ((int)(duty_cycle*100)), ((int) (duty_cycle * PWM_RPM_MAX * RPM_TO_DEG_PER_SEC)));
      
      if (USM_MAX_DUTY_CYCLE < duty_cycle){ // limit it to the max value
        if (PRINT_USM)printf("Hit max duty cycle! Setting to %d%\r\n", ((int)(USM_MAX_DUTY_CYCLE*100)));
        duty_cycle = USM_MAX_DUTY_CYCLE;
      }

      if (duty_cycle < USM_MIN_DUTY_CYCLE){ // limit it to the max value
        if (PRINT_USM)printf("Hit min duty cycle! Setting to %d%\r\n", 0);
        duty_cycle = 0.0;
      }
      return duty_cycle;
      //int ccr = ((int) (((float) ARR_PERIOD) * duty_cycle));
      //return ccr; //((int) (((float) ARR_PERIOD) * duty_cycle)); // CCR = AAR * duty_cycle [percentage]
    }

    float convert_speed_rad_per_sec_to_duty_cycle(float speed_rad_per_sec){
      return apply_duty_cycle_limits(speed_rad_per_sec / ((float)(PWM_RAD_PER_SEC_MAX)));
    }

    int convert_duty_cycle_to_pwm_ccr(float duty_cycle){
      int ccr = ((int) (((float) ARR_PERIOD) * duty_cycle));
      return ccr; //((int) (((float) ARR_PERIOD) * duty_cycle)); // CCR = AAR * duty_cycle [percentage]
    }

    int convert_speed_rpm_to_pwm_ccr(float speed_rpm){
      //float duty_cycle = speed_rpm / ((float) PWM_RPM_MAX; // duty cycle is normalized by it's max value.
      return convert_duty_cycle_to_pwm_ccr(apply_duty_cycle_limits(speed_rpm / ((float) PWM_RPM_MAX))); // duty cycle is normalized by it's max value.
    }

    // debugging behavior for motors
    void debug_duty_cycle_sweep(){
      //long now_tick = HAL_GetTick(); // gives miliseconds since last stm32 reset
      float interval_sec = (((float) (HAL_GetTick() - reference_tick_usm)) * MSEC_TO_SEC);
      //printf("interval_sec (int): %d\r\n", ((int) interval_sec * 1000));

      if (debug_duty_cycle_sweep_time_interval < interval_sec){
        reference_tick_usm = HAL_GetTick();
        
        //debug_duty_cycle = fmodf(debug_duty_cycle + debug_duty_cycle_sweep_increment, USM_MAX_DUTY_CYCLE);
        debug_duty_cycle += debug_duty_cycle_sweep_increment;
        if (USM_MAX_DUTY_CYCLE < debug_duty_cycle){
          debug_duty_cycle = 0.0;
        }

        printf("New debug_duty_cycle: (%d / 100)percent, (%d CCR / %d ARR) \r\n", ((int)(debug_duty_cycle * 10000.0)),
        convert_duty_cycle_to_pwm_ccr(debug_duty_cycle), ARR_PERIOD);//_conv_float(debug_duty_cycle));
        
      }
      TIM3->CCR1 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM0
      TIM3->CCR2 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM1
      TIM3->CCR3 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM2
      TIM3->CCR4 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM3
      TIM4->CCR1 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM4
      TIM4->CCR2 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM5
      TIM4->CCR3 = convert_duty_cycle_to_pwm_ccr(debug_duty_cycle);  // Set period for USM6
    }

    extern TIM_HandleTypeDef htim3; // used for USM PWM
    extern TIM_HandleTypeDef htim4; // used for USM PWM

    volatile float speed_[7] = {0, 0, 0, 0, 0, 0, 0}; // internal copy of speed, not a reactor state because is changed inplace with preamble functions
    volatile float usm_duty_cycle_[7] = {0, 0, 0, 0, 0, 0, 0}; // not a reactor state because is changed inplace with preamble functions

    static void MX_TIM3_Init(void) {
      TIM_ClockConfigTypeDef sClockSourceConfig = {0};
      TIM_MasterConfigTypeDef sMasterConfig = {0};
      TIM_OC_InitTypeDef sConfigOC = {0};

      htim3.Instance = TIM3;
      htim3.Init.Prescaler = 0;
      htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
      htim3.Init.Period = ARR_PERIOD; //1000;
      htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
      htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
      HAL_TIM_Base_Init(&htim3);

      sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
      HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);

      HAL_TIM_PWM_Init(&htim3);

      sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
      sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
      HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
      sConfigOC.OCMode = TIM_OCMODE_PWM1;
      sConfigOC.Pulse = 0;
      sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
      sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;

      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4);
      HAL_TIM_MspPostInit(&htim3);
    }

    static void MX_TIM4_Init(void)
    {
      TIM_ClockConfigTypeDef sClockSourceConfig = {0};
      TIM_MasterConfigTypeDef sMasterConfig = {0};
      TIM_OC_InitTypeDef sConfigOC = {0};

      htim4.Instance = TIM4;
      htim4.Init.Prescaler = 0;
      htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
      htim4.Init.Period = ARR_PERIOD; //1000
      htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
      htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
      HAL_TIM_Base_Init(&htim4);
      
      sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
      HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig);
      HAL_TIM_PWM_Init(&htim4);
      sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
      sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
      HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig);
      sConfigOC.OCMode = TIM_OCMODE_PWM1;
      sConfigOC.Pulse = 0;
      sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
      sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
      HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1);
      HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2);
      HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3);
      HAL_TIM_MspPostInit(&htim4);

    }

    static void USM_GPIO_Init(void) {
      GPIO_InitTypeDef GPIO_InitStruct = {0};
      __HAL_RCC_GPIOB_CLK_ENABLE();
      __HAL_RCC_GPIOC_CLK_ENABLE();

      //+----------------------------------------------------------------+
      //  Name,     PWM     Direction,    Enable
      //  USM_0,    PB4,    PC13,         PB1
      //  USM_1,    PB5,    PC14,         PB2
      //  USM_2,    PC8,    PC15,         PB3
      //  USM_3,    PC9,    PC4,          PB9
      //  USM_4,    PB6,    PC5,          PB10
      //  USM_5,    PB7,    PB15,         PB12
      //  USM_6,    PB8,    PB14,         PB13
      //+----------------------------------------------------------------+

      // Configure output pins (DIR/EN)
      HAL_GPIO_WritePin(GPIOA,  GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      
      HAL_GPIO_WritePin(GPIOB,  GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_10|
        GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_10|
                            GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      
      HAL_GPIO_WritePin(GPIOC,  GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

      // Configure input pins (ON/OFF Switch) PC3
      GPIO_InitStruct.Pin = GPIO_PIN_3;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

      // Configure output pin (Status LED)
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_0;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }

    void set_motor_enable_pins(bool set_value){
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0,    set_value); // PB0 is the LED
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1,    set_value);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2,    set_value);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3,    set_value);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    set_value);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10,   set_value);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,   set_value);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,   set_value);
      HAL_Delay(1);
    }

    void enforce_speed_bounds(){
      for (int i = 0; i<7; i++){
        if (speed_[i] < -motor_configs[i]->max_speed){
          if (PRINT_USM) printf("Speed of speed_[%d]*1000 (%d) is less than --motor_configs[%d]->max_speed*1000 (%d)!\r\n", i, ((int)speed_[i]*1000), i, ((int)(-motor_configs[i]->max_speed*1000)));
          speed_[i] = -motor_configs[i]->max_speed;
          
        }
        else if (motor_configs[i]->max_speed < speed_[i]){
          speed_[i] = motor_configs[i]->max_speed;
          if (PRINT_USM)printf("Speed of speed_[%d]*1000 (%d) is greater than motor_configs[%d]->max_speed*1000 (%d)!\r\n", i, ((int)speed_[i]*1000), i, ((int)(motor_configs[i]->max_speed*1000)));
        }
        else{
          // speed_[i] is in expected range.
        }
      }
      return;
    }
    
    void set_direction_pins(){
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13,   speed_[0] >= 0); // 1 if non-negative, 0 if negative
      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5,    speed_[1] >= 0);
      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6,    speed_[2] >= 0);
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,    speed_[3] >= 0);
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5,    speed_[4] >= 0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,   speed_[5] >= 0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,   speed_[6] >= 0);
      HAL_Delay(1);
      return;
    }

    void set_motor_pwm_registers(){
      for (int i = 0; i < 7; i++){
        usm_duty_cycle_[i] = convert_speed_rad_per_sec_to_duty_cycle(speed_[i]);
      }
      TIM3->CCR1 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[0]);  // Set period for USM0
      TIM3->CCR2 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[1]);  // Set period for USM1
      TIM3->CCR3 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[2]);  // Set period for USM2
      TIM3->CCR4 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[3]);  // Set period for USM3
      TIM4->CCR1 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[4]);  // Set period for USM4
      TIM4->CCR2 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[5]);  // Set period for USM5
      TIM4->CCR3 = convert_duty_cycle_to_pwm_ccr(usm_duty_cycle_[6]);  // Set period for USM6
      //HAL_Delay(1);
    }

    float apply_motor_direction_change(float speed, int index){
      return speed * ((float) motor_configs[index]->dir);
    }

    float apply_gear_ratio(float speed, int index){
      return speed * ((float) motor_configs[index]->gear_ratio);
    }
  =}


  reaction(startup) {=
    // for debugging
    reference_tick_usm = HAL_GetTick();

    //
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();


    MX_TIM3_Init();
    MX_TIM4_Init();
    USM_GPIO_Init();

    // Initially set all enable values to 0
    set_motor_enable_pins(false);

    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);   // USM_0, PB4
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);   // USM_1, PB5
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);   // USM_2, PC8
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);   // USM_3, PC9
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);   // USM_4, PB6
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);   // USM_5, PB7
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);   // USM_5, PB8
  =}

  reaction(force_disable_motor_pins) {=
    self->_force_disable_motor_pins = force_disable_motor_pins->value;
    if (PRINT_USM){printf("Set _force_disable_motor_pins to %d given input %d.\r\n", self->_force_disable_motor_pins, force_disable_motor_pins->value);}
    if (force_disable_motor_pins->value){
      set_motor_enable_pins(false);
    }
  =}

  reaction(speed) -> commanded_duty_cycle{=
    
    // save internal speed_ values
    for (int i = 0; i<7; i++){
      speed_[i] = apply_gear_ratio(apply_motor_direction_change(speed[i]->value, i), i);
    }

    // Set USM values if we're not in the safey idle mode
    if (self->_force_disable_motor_pins){
      if (PRINT_USM){printf("USM: Force disabling all motor pins\r\n");}
      set_motor_enable_pins(false);
    }
    else {

      // ensures all motor pins are enabled
      set_motor_enable_pins(true);

      // enforces all set speed bounds from motor_config.h
      //enforce_speed_bounds(); // put these back on later!

      // Set USM direction values based on sign of speed_
      set_direction_pins();
      
      
      // ONLY FOR DEBUGGING PWMs
      //if (PRINT_USM){
      //  printf("(int)(speed_[0]*1000.0): %d, convert_speed_rad_per_sec_to_pwm_ccr(speed_[0]): %d, convSpeed(speed_[0], 0): %d\r\n", (int)(speed_[0]*1000.0), convert_speed_rad_per_sec_to_pwm_ccr(speed_[0]), convSpeed(speed_[0], 0));
      //}
      //for (int i = 0; i<7; i++){
      //  speed_[i] = (speed_[i] / 0.087266) * 26.179938749999998; // speed/5[deg/s] * 250[rpm] -> puts it in normalized units to test out full range of pwm
      //}

      if (PRINT_USM){
        for (int i = 0; i<7;i++){
          printf("Motor %d: Commanding %d milli rads/sec or %d Deg/s, CCR of %d.\r\n", i, (int)(1000 * speed_[i]), (int)(RAD_PER_SEC_TO_DEG_PER_SEC * speed_[i]), convert_speed_rad_per_sec_to_pwm_ccr(speed_[i]));
        }
      }
      // Set USM speed values
      if (DO_DEBUG_PWM_SWEEP){
        debug_duty_cycle_sweep();
      } else{
        set_motor_pwm_registers();
      }

      for (int i = 0; i<7; i++) {lf_set(commanded_duty_cycle[i], usm_duty_cycle_[i]);} // usm_duty_cycle_ is set internally by set_motor_pwm_registsers
      
    }
  
  =}

}

/* // was at top of reaction(speed)
    en_usm = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_3) && !HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_2); 
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, en_usm); // PB0 is the LED
    
    if (PRINT_USM) {printf("USM: en_usm=%d, force_disable=%d\r\n", en_usm, self->_force_disable_motor_pins);}

    // for writing USM convSpeeds
    if (PRINT_USM && printcnt>=printcnt_lim) {
        printf("USM convSpeed: ");
    }

    for (int i=0; i<7; i++) {
      speed_[i] = en_usm? speed[i]->value * motor_configs[i]->dir : 0;
      
      if (PRINT_USM) {printf("USM: speed_[%d] = %d (from input %d, en_usm=%d)\r\n",
             i, (int)(speed_[i] * 1000), (int)(speed[i]->value * 1000), en_usm);
      }
      
      if (PRINT_USM && printcnt>=printcnt_lim) {
          printf("%d  ", convSpeed(speed_[i], i));
      }
    }
    if (PRINT_USM && printcnt>=printcnt_lim) {
          printf("\r\n");
    }
    */
/* // fix these limits!
      // set enable pins if speeds are within the limits
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0,    1); // PB0 is the LED
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1,    speed_[0] > USM_LIMIT || speed_[0] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2,    speed_[1] > USM_LIMIT || speed_[1] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3,    speed_[2] > USM_LIMIT || speed_[2] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    speed_[3] > USM_LIMIT || speed_[3] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10,   speed_[4] > USM_LIMIT || speed_[4] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,   speed_[5] > USM_LIMIT || speed_[5] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,   speed_[6] > USM_LIMIT || speed_[6] < -USM_LIMIT);
      HAL_Delay(1);
      */

/*
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13,   speed_[0] >= 0);
      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5,    speed_[1] >= 0);
      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6,    speed_[2] >= 0);
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,    speed_[3] >= 0);
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5,    speed_[4] >= 0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,   speed_[5] >= 0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,   speed_[6] >= 0);
      HAL_Delay(1);
      */
      

      // Set USM speed values
      /*
      TIM3->CCR1 = speed_[0];//convSpeed(speed_[0], 0);  // Set period for USM0
      TIM3->CCR2 = convSpeed(speed_[1], 1);  // Set period for USM1
      TIM3->CCR3 = convSpeed(speed_[2], 2);  // Set period for USM2
      TIM3->CCR4 = convSpeed(speed_[3], 3);  // Set period for USM3
      TIM4->CCR1 = convSpeed(speed_[4], 4);  // Set period for USM4
      TIM4->CCR2 = convSpeed(speed_[5], 5);  // Set period for USM5
      TIM4->CCR3 = convSpeed(speed_[6], 6);  // Set period for USM6
      HAL_Delay(1);
      */
