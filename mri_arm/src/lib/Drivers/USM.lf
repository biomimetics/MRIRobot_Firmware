target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include <stdio.h>
  #include <stdlib.h>
  #include <math.h> // need for floating point abs, or fabsf()
  #include <../../../motor_config.h>

  // only these two consts are needed if output pin is reliably 3.3V at 100% duty cycle.
  #define ARR_PERIOD 65535 // 16-bit timer period for ARR (auto reload register)
  #define PWM_RPM_MAX 250.0 // 250 RPM
  
  // these two consts aren't needed if we can assume 3.3V is the max pin voltage. Make sure it's not a 5V output!
  #define PWM_VOLTAGE_MAX 3.3 // voltage at [3.3V] 100% duty cycle
  #define PWM_RPM_PER_VOLT 75.757576 // 250.0RPM / 3.3V based on tekceleo datasheet for WLG-75-R motors

  // safety const
  #define USM_MAX_DUTY_CYCLE 0.5 // only higher than 6% for PWM pin testing //0.06 // 6% duty cycle

  // conversion for if inputs are in rad_per_sec
  #define RAD_PER_SEC_TO_RPM 9.549297

=}

reactor USM {
  input[7] speed: float
  input force_disable_motor_pins: bool

  state _force_disable_motor_pins: bool = false

  //state force_disable_motor_pins
  preamble {=

    // note that all of this assumes a max voltage of 3.3V! If it's actually different, these numbers are wrong.
    int convert_speed_rpm_to_pwm_ccr(float speed_rpm){
      float duty_cycle = 0.0;
      //printf("(int)(speed_rpm * 1000.0): %d\r\n", (int)(speed_rpm * 1000.0));
      //printf("(int)(fabsf(speed_rpm) * 1000.0): %d\r\n", (int)(fabsf(speed_rpm) * 1000.0));
      //printf("(int)PWM_RPM_MAX: %d", (int)PWM_RPM_MAX);
      duty_cycle = fabsf(speed_rpm) / ((float) PWM_RPM_MAX);
      //printf("(int)(duty_cycle * 100000.0): %d\r\n", (int)(duty_cycle * 100000.0));
      if (duty_cycle > USM_MAX_DUTY_CYCLE){
        duty_cycle = USM_MAX_DUTY_CYCLE;
      }
      //printf("((int) (((float) ARR_PERIOD) * duty_cycle)): %d\r\n", ((int) (((float) ARR_PERIOD) * duty_cycle)));
      return ((int) (((float) ARR_PERIOD) * duty_cycle)); // CCR = AAR * duty_cycle [percentage]
    }

    int convert_speed_rad_per_sec_to_pwm_ccr(float speed_rad_per_sec){
      //printf("(int)(speed_rad_per_sec * 1000): %d\r\n", (int)(speed_rad_per_sec * 1000));
      return convert_speed_rpm_to_pwm_ccr(RAD_PER_SEC_TO_RPM * speed_rad_per_sec);
    }

    extern TIM_HandleTypeDef htim1; // unused
    extern TIM_HandleTypeDef htim2; // unused
    extern TIM_HandleTypeDef htim3; // used for USM PWM
    extern TIM_HandleTypeDef htim4; // used for USM PWM

    volatile float _speed[7] = {0, 0, 0, 0, 0, 0, 0};
    volatile float USM_LIMIT = 0.06;
    volatile int en_usm;

    static int print_usm = false;
    static int printcnt = 0;
    static int printcnt_lim = 500;

    static void MX_TIM3_Init(void) {
      TIM_ClockConfigTypeDef sClockSourceConfig = {0};
      TIM_MasterConfigTypeDef sMasterConfig = {0};
      TIM_OC_InitTypeDef sConfigOC = {0};

      htim3.Instance = TIM3;
      htim3.Init.Prescaler = 0;
      htim3.Init.CounterMode = TIM_COUNTERMODE_UP;
      htim3.Init.Period = ARR_PERIOD; //1000;
      htim3.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
      htim3.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
      ;HAL_TIM_Base_Init(&htim3);

      sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
      HAL_TIM_ConfigClockSource(&htim3, &sClockSourceConfig);

      HAL_TIM_PWM_Init(&htim3);

      sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
      sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
      HAL_TIMEx_MasterConfigSynchronization(&htim3, &sMasterConfig);
      sConfigOC.OCMode = TIM_OCMODE_PWM1;
      sConfigOC.Pulse = 0;
      sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
      sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;

      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_1);
      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_2);
      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_3);
      HAL_TIM_PWM_ConfigChannel(&htim3, &sConfigOC, TIM_CHANNEL_4);
      HAL_TIM_MspPostInit(&htim3);
    }

    static void MX_TIM4_Init(void)
    {
      TIM_ClockConfigTypeDef sClockSourceConfig = {0};
      TIM_MasterConfigTypeDef sMasterConfig = {0};
      TIM_OC_InitTypeDef sConfigOC = {0};

      htim4.Instance = TIM4;
      htim4.Init.Prescaler = 0;
      htim4.Init.CounterMode = TIM_COUNTERMODE_UP;
      htim4.Init.Period = ARR_PERIOD; //1000;
      htim4.Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
      htim4.Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
      HAL_TIM_Base_Init(&htim4);
      
      sClockSourceConfig.ClockSource = TIM_CLOCKSOURCE_INTERNAL;
      HAL_TIM_ConfigClockSource(&htim4, &sClockSourceConfig);
      HAL_TIM_PWM_Init(&htim4);
      sMasterConfig.MasterOutputTrigger = TIM_TRGO_RESET;
      sMasterConfig.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE;
      HAL_TIMEx_MasterConfigSynchronization(&htim4, &sMasterConfig);
      sConfigOC.OCMode = TIM_OCMODE_PWM1;
      sConfigOC.Pulse = 0;
      sConfigOC.OCPolarity = TIM_OCPOLARITY_HIGH;
      sConfigOC.OCFastMode = TIM_OCFAST_DISABLE;
      HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_1);
      HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_2);
      HAL_TIM_PWM_ConfigChannel(&htim4, &sConfigOC, TIM_CHANNEL_3);
      HAL_TIM_MspPostInit(&htim4);

    }

    static void USM_GPIO_Init(void) {
      GPIO_InitTypeDef GPIO_InitStruct = {0};
      __HAL_RCC_GPIOB_CLK_ENABLE();
      __HAL_RCC_GPIOC_CLK_ENABLE();

      //+----------------------------------------------------------------+
      //  Name,     PWM     Direction,    Enable
      //  USM_0,    PB4,    PC13,         PB1
      //  USM_1,    PB5,    PC14,         PB2
      //  USM_2,    PC8,    PC15,         PB3
      //  USM_3,    PC9,    PC4,          PB9
      //  USM_4,    PB6,    PC5,          PB10
      //  USM_5,    PB7,    PB15,         PB12
      //  USM_6,    PB8,    PB14,         PB13
      //+----------------------------------------------------------------+

      // Configure output pins (DIR/EN)
      HAL_GPIO_WritePin(GPIOA,  GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_6;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);
      
      HAL_GPIO_WritePin(GPIOB,  GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_10|
        GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_1|GPIO_PIN_2|GPIO_PIN_3|GPIO_PIN_9|GPIO_PIN_10|
                            GPIO_PIN_12|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
      
      HAL_GPIO_WritePin(GPIOC,  GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_4|GPIO_PIN_5|GPIO_PIN_13|GPIO_PIN_14|GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_PULLDOWN;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

      // Configure input pins (ON/OFF Switch) PC3
      GPIO_InitStruct.Pin = GPIO_PIN_3;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

      // Configure output pin (Status LED)
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_0;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
    }

    static int min(int a, int b) {
      return a<b? a: b;
    }

    static int max(int a, int b) {
      return a>b? a: b;
    }

    static int convSpeed(float speed, int idx) {
      float USM_MIN_SPEED = 3;
      if (speed < 0)
        return  min((int)((1000 * max(USM_MIN_SPEED, -speed) * motor_configs[idx]->speed_ratio)/100), motor_configs[idx]->max_speed);
      else
        return  min((int)((1000 * max(USM_MIN_SPEED, speed) * motor_configs[idx]->speed_ratio)/100), motor_configs[idx]->max_speed);
    }

  =}


  reaction(startup) {=
    __HAL_RCC_GPIOA_CLK_ENABLE();
    __HAL_RCC_GPIOB_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();


    MX_TIM3_Init();
    MX_TIM4_Init();
    USM_GPIO_Init();

    // Initially set all enable values to 0
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1, 0);    // for USM0
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2, 0);    // for USM1
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3, 0);    // for USM2
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9, 0);    // for USM3
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10, 0);   // for USM4
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12, 0);   // for USM5
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13, 0);   // for USM5

    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_1);   // USM_0, PB4
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_2);   // USM_1, PB5
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_3);   // USM_2, PC8
    HAL_TIM_PWM_Start(&htim3, TIM_CHANNEL_4);   // USM_3, PC9
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_1);   // USM_4, PB6
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_2);   // USM_5, PB7
    HAL_TIM_PWM_Start(&htim4, TIM_CHANNEL_3);   // USM_5, PB8
  =}

  reaction(force_disable_motor_pins) {=
    self->_force_disable_motor_pins = force_disable_motor_pins->value;
    if (print_usm){printf("Set _force_disable_motor_pins to %d given input %d.\r\n", self->_force_disable_motor_pins, force_disable_motor_pins->value);}
    if (force_disable_motor_pins->value){
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0,    0); // PB0 is the LED
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10,   0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,   0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,   0);
      HAL_Delay(1);
    }
  =}

  reaction(speed) {=
    //bool _force_disable_motor_pins = 0; // TODO: FIX THIS ASAP
    // TODO: get rid of these switches. en_usm is probably "enable_usm", but why is it the result of two seperate pins?
    en_usm = HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_3) && !HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_2); 
    HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0, en_usm); // PB0 is the LED
    
    if (print_usm) {printf("USM: en_usm=%d, force_disable=%d\r\n", en_usm, self->_force_disable_motor_pins);}

    // for writing USM convSpeeds
    if (print_usm && printcnt>=printcnt_lim) {
        printf("USM convSpeed: ");
    }

    for (int i=0; i<7; i++) {
      _speed[i] = en_usm? speed[i]->value * motor_configs[i]->dir : 0;
      
      if (print_usm) {printf("USM: _speed[%d] = %d (from input %d, en_usm=%d)\r\n",
             i, (int)(_speed[i] * 1000), (int)(speed[i]->value * 1000), en_usm);
      }
      
      if (print_usm && printcnt>=printcnt_lim) {
          printf("%d  ", convSpeed(_speed[i], i));
      }
    }
    if (print_usm && printcnt>=printcnt_lim) {
          printf("\r\n");
    }

    // Set USM enable values
    
    if (self->_force_disable_motor_pins){
      if (print_usm){printf("USM: Force disabling all motor pins\r\n");}
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0,    0); // PB0 is the LED
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10,   0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,   0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,   0);
      HAL_Delay(1);
    }
    else {
      /*
      if (print_usm){printf("USM: Setting motor enables: [%d %d %d %d %d %d %d]\r\n",
             (_speed[0] > USM_LIMIT || _speed[0] < -USM_LIMIT),
             (_speed[1] > USM_LIMIT || _speed[1] < -USM_LIMIT),
             (_speed[2] > USM_LIMIT || _speed[2] < -USM_LIMIT),
             (_speed[3] > USM_LIMIT || _speed[3] < -USM_LIMIT),
             (_speed[4] > USM_LIMIT || _speed[4] < -USM_LIMIT),
             (_speed[5] > USM_LIMIT || _speed[5] < -USM_LIMIT),
             (_speed[6] > USM_LIMIT || _speed[6] < -USM_LIMIT));
      }
      */
      /* // fix these limits!
      // set enable pins if speeds are within the limits
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0,    1); // PB0 is the LED
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1,    _speed[0] > USM_LIMIT || _speed[0] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2,    _speed[1] > USM_LIMIT || _speed[1] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3,    _speed[2] > USM_LIMIT || _speed[2] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    _speed[3] > USM_LIMIT || _speed[3] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10,   _speed[4] > USM_LIMIT || _speed[4] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,   _speed[5] > USM_LIMIT || _speed[5] < -USM_LIMIT);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,   _speed[6] > USM_LIMIT || _speed[6] < -USM_LIMIT);
      HAL_Delay(1);
      */

      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_0,    1); // PB0 is the LED
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_1,    1);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_2,    1);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_3,    1);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    1);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_10,   1);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_12,   1);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_13,   1);
      HAL_Delay(1);


      // Set USM direction values based on sign of _speed
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_13,   _speed[0] >= 0);
      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_5,    _speed[1] >= 0);
      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_6,    _speed[2] >= 0);
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_4,    _speed[3] >= 0);
      HAL_GPIO_WritePin(GPIOC, GPIO_PIN_5,    _speed[4] >= 0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_15,   _speed[5] >= 0);
      HAL_GPIO_WritePin(GPIOB, GPIO_PIN_14,   _speed[6] >= 0);
      HAL_Delay(1);

      /*
      // Set USM speed values
      TIM3->CCR1 = convSpeed(_speed[0], 0);  // Set period for USM0
      TIM3->CCR2 = convSpeed(_speed[1], 1);  // Set period for USM1
      TIM3->CCR3 = convSpeed(_speed[2], 2);  // Set period for USM2
      TIM3->CCR4 = convSpeed(_speed[3], 3);  // Set period for USM3
      TIM4->CCR1 = convSpeed(_speed[4], 4);  // Set period for USM4
      TIM4->CCR2 = convSpeed(_speed[5], 5);  // Set period for USM5
      TIM4->CCR3 = convSpeed(_speed[6], 6);  // Set period for USM6
      */
        
      // do a safety check on the _speed values first to make sure they're in the desired range

      // send the safe speeds to the CCR channels for the two timers

      if (print_usm || true){
        printf("(int)(_speed[2]*1000.0): %d, convert_speed_rad_per_sec_to_pwm_ccr(_speed[2]): %d\r\n", (int)(_speed[2]*1000.0), convert_speed_rad_per_sec_to_pwm_ccr(_speed[2]));
      }
      TIM3->CCR1 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[0]);  // Set period for USM0
      TIM3->CCR2 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[1]);  // Set period for USM1
      TIM3->CCR3 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[2]);  // Set period for USM2
      TIM3->CCR4 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[3]);  // Set period for USM3
      TIM4->CCR1 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[4]);  // Set period for USM4
      TIM4->CCR2 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[5]);  // Set period for USM5
      TIM4->CCR3 = convert_speed_rad_per_sec_to_pwm_ccr(_speed[6]);  // Set period for USM6

      printcnt = (printcnt >= printcnt_lim) ? 0 : printcnt+1;
    }
  
  =}

}
