target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include <stdio.h>
  #include <../../../include/motor_config.h>
  
=}

reactor QDEC(sample_period: time = 5 ms){
  mutable input reset_qdec: bool
  mutable input enable_qdec: bool

  output[7] qdec_out: float
  output[7] sea_out: float

  output[7] qdec_vel_out: float

  timer trigger(0, sample_period)
  timer enable(0, 20 ms)
  timer print_timer(0, 5000 ms)

  state reset_qdec_: bool = false
  state enable_qdec_: bool = false

  // internal copies of joint and sea encoder values to use
  state qdec_pos_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
  state qdec_pos_last_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
  state qdec_vel_est_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}

  state qdec_convert_motor_to_joint_rad_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0} // conversion from motor space to acutator space
  state qdec_convert_sea_to_joint_rad_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0} // conversion from sea space to acutator space

  state sea_pos_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
  state sea_pos_last_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0} // unused!
  state sea_vel_est_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0} // unused!

  state prev_time: time = 0

  // timer_states
  state timer_start_: uint32_t = 0
  state timer_elapsed_time_sec_: double = 0.0
  state interval_sec: float = 0.0
  
  preamble {=
    extern UART_HandleTypeDef huart3;

    extern DMA_HandleTypeDef hdma_usart3_rx;
    extern DMA_HandleTypeDef hdma_usart3_tx;

    //static int PRINT_ENCODER = true; // move all of these to define statements in a central location. annoying to track them down.
    static int printcnt = 0;
    static int printcnt_lim = 10;//100; // print every nth time


    // QDEC Commands
    uint8_t qdec_reset[1]= {0x01};            // Reset QDEC values
    uint8_t qdec_disable[1]= {0x02};          // Disable encoders
    uint8_t qdec_enable[1]= {0x03};           // Enable encoders
    uint8_t req_qdec[2]=  {0x04, 0x05};       // Request data

    float pi = 3.14159;
    static uint8_t data[200];
    static long count[14];

    // for storing usm and sea encoder counts
    static long usm_counts[7];
    static long sea_counts[7];

    // unexplained conversion factors found in the code applied to the sea counts before the sea gear reduction
    // all I know is "// 0.362 = 25.4/70" and "// 0.5644 = 25.4/45", so maybe 25.4 is mm and 70/45 are degrees? Maybe this factor converts the counts per inch to counts per degree? 
    //float magic_sea_count_conv[] = {0.5644, 0.5644, 0.5644, 0.5644, 0.3624, 0.3624, 0.3624}; // OLD
    float magic_sea_count_conv[] = {0.5644, 0.5644, 0.5644, 0.3624, 0.3624, 0.3624, 0.3624}; // NEW

    static void MX_DMA_Init(void) {
      /* DMA controller clock enable */
      __HAL_RCC_DMA1_CLK_ENABLE();

      /* DMA interrupt init */
      /* DMA1_Stream1_IRQn interrupt configuration */
      HAL_NVIC_SetPriority(DMA1_Stream1_IRQn, 0, 0);
      HAL_NVIC_EnableIRQ(DMA1_Stream1_IRQn);
      
      /* DMA1_Stream3_IRQn interrupt configuration */
      HAL_NVIC_SetPriority(DMA1_Stream3_IRQn, 0, 0);
      HAL_NVIC_EnableIRQ(DMA1_Stream3_IRQn);
    }

    static void MX_UART3_Init(void) {
      huart3.Instance = USART3;
      huart3.Init.BaudRate = 921600;
      huart3.Init.WordLength = UART_WORDLENGTH_8B;
      huart3.Init.StopBits = UART_STOPBITS_1;
      huart3.Init.Parity = UART_PARITY_NONE;
      huart3.Init.Mode = UART_MODE_TX_RX;
      huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
      huart3.Init.OverSampling = UART_OVERSAMPLING_16;
      HAL_UART_Init(&huart3);
    }

    static void MX_GPIO_Init(void) {
      GPIO_InitTypeDef GPIO_InitStruct = {0};
      __HAL_RCC_GPIOB_CLK_ENABLE();

      HAL_GPIO_WritePin(GPIOA, GPIO_PIN_15, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_15;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

      /* Configure Switch pins : PC1, PC2, PC3 */
      GPIO_InitStruct.Pin = GPIO_PIN_2;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);
    }

    // Recieve callback function
    void HAL_UART_RxCallback3() {
      HAL_UART_Receive_DMA(&huart3, data, 98);
    }

    static int last_switch = 0;
    long reference_tick = 0;
    long current_tick = 0;

    uint32_t timer_start_enc_ = 0;
    double timer_elapsed_time_sec_enc_ = 0;
  =}

  reaction(startup) {=
    MX_DMA_Init();
    MX_UART3_Init();
    MX_GPIO_Init();

    if (PRINT_ENCODER){printf("Encoder.lf: startup: Reseting and enableing qdec...\r\n");}
    HAL_UART_Transmit(&huart3, qdec_reset, 1, HAL_MAX_DELAY);
    HAL_UART_Transmit(&huart3, qdec_enable, 1, HAL_MAX_DELAY);

    HAL_UART_Receive_DMA(&huart3, data, 98);
    HAL_UART_Transmit(&huart3, req_qdec, 2, HAL_MAX_DELAY);

    // computing conversions from motor/encoder space to joint space
    for (int i = 0; i<7; i++){
      self->qdec_convert_motor_to_rad_[i] = (TWO_PI) / (motor_configs[i]->qdec_cpr);
      //self->qdec_convert_motor_to_joint_rad_[i] = (TWO_PI) / (motor_configs[i]->qdec_cpr * motor_configs[i]->gear_ratio) * motor_configs[i]->dir;
    }



    for (int i = 0; i<7; i++){
      //self->qdec_convert_sea_to_joint_rad_[i] = (TWO_PI / 360.0) * magic_sea_count_conv[i] * (motor_configs[i]->sea_gear_ratio) / (motor_configs[i]->gear_ratio * motor_configs[i]->sea_cpr);
      self->qdec_convert_sea_to_rad_[i] = (TWO_PI) / (motor_configs[i]->sea_cpr); // should convert from sea counts to radians
      //self->qdec_convert_sea_to_joint_rad_[i] = (TWO_PI) * (motor_configs[i]->sea_gear_ratio) / (motor_configs[i]->gear_ratio * motor_configs[i]->sea_cpr); // should convert from sea counts to radians
    }

    self->prev_time = lf_time_physical(); //lf_time_physical(); //lf_time_physical_elapsed
    reference_tick = HAL_GetTick(); // gives miliseconds since last reboot
  =}

  reaction(reset_qdec) {=
    self->reset_qdec_ = reset_qdec->value;
    if (self->reset_qdec_){
      HAL_UART_Transmit(&huart3, qdec_reset, 1, HAL_MAX_DELAY);
      HAL_UART_Receive_DMA(&huart3, data, 98);
    }
    self->reset_qdec_ = false; 
    reset_qdec->value = self->reset_qdec_;// should work if reset_qdec is mutable?
  =}

  reaction(enable_qdec) {=
    self->enable_qdec_ = enable_qdec->value; // sets other reactions/methods know if encoders are active or not

    if (self->enable_qdec_){
      HAL_UART_Transmit(&huart3, qdec_enable, 1, HAL_MAX_DELAY);
      if (PRINT_ENCODER) {printf("Enabling Encoders\r\n");}
    } else {
      HAL_UART_Transmit(&huart3, qdec_disable, 1, HAL_MAX_DELAY);
      if (PRINT_ENCODER) {printf("Disabling Encoders\r\n");}
    }

  =}


  // Update Encoder values
  // This function should take approximately 1ms to operate
  reaction(trigger) -> qdec_out, qdec_vel_out, sea_out {=

    timer_updated_elapsed_time(&self->timer_start_, &self->timer_elapsed_time_sec_); // comptues the interval in seconds

    if (DO_INTERVAL_OVERRIDE){
      self->interval_sec = (float) OVERRIDE_INTERVAL;
    }
    else {
      self->interval_sec = (float) self->timer_elapsed_time_sec_;
    }
    

    // Prep the next request
    HAL_UART_Transmit(&huart3, req_qdec, 2, HAL_MAX_DELAY);

    // Shift over relevant data
    for(int i=0; i<14; i++) {
      count[i] = data[0+(i*7)] + (data[1+(i*7)]<<8) + (data[2+(i*7)]<<16) + (data[3+(i*7)]<<24) 
                               + (data[4+(i*7)]<<32) + (data[5+(i*7)]<<40) + (data[6+(i*7)]<<48);
    }
    
    // unpack the count array into sea and usm counts
    for (int i=0; i<7; i++){
      sea_counts[i] = count[6-i]; // they're stored backwards for the seas
    }
    for (int i=0; i<7; i++){
      usm_counts[i] = count[i+7];
    }

    
    // Get values for SEA encoders
    for (int i=0; i<7; i++) {
      float sea_value = ((float) sea_counts[i]) * self->qdec_convert_sea_to_rad_[i]; // - motor_configs[i]->sea_offset;

      lf_set(sea_out[i],  sea_value);
    }

    // Get values for USM encoders
    for (int i=0; i<7; i++) {
      self->qdec_pos_last_[i] = self->qdec_pos_[i]; // save last position
      self->qdec_pos_[i] = ((float) usm_counts[i]) * self->qdec_convert_motor_to_rad_[i]; // update the new position
      self->qdec_vel_est_[i] = (self->qdec_pos_[i] - self->qdec_pos_last_[i]) / (self->interval_sec); //(interval_sec); // estimate velocity from different of positions over the time between positions

      lf_set(qdec_out[i],  self->qdec_pos_[i]); // should be units of radians
      lf_set(qdec_vel_out[i],  self->qdec_vel_est_[i]); // should be units of radians per second
    }
    
    if (PRINT_ENCODER && printcnt>=printcnt_lim){
      //printf("encoder interval_sec: Got %d us.\r\n", ((int)(self->interval_sec * 1000000.0))); //self->sample_period);

      printf("sea: ");
      for (int i = 0; i<7; i++){
        printf("%d  ", (int) (sea_out[i]->value*1000));
      }
      printf("\r\nsea_counts: ");
      for (int i = 0; i<7; i++){
        printf("%d  ", (int) (sea_counts[i]));
      }
      
      printf("\r\nqdec [mRad]: ");
      for (int i = 0; i<7; i++){
        printf("%d  ", (int) (qdec_out[i]->value*1000));
      }
      printf("\r\nqdec_vel [mRad/s]: ");
      for (int i = 0; i<7; i++){
        printf("%d  ", (int) (qdec_vel_out[i]->value*1000));
      }
      printf("\r\ninterval [ms] %d, [us]: %d", (int) (self->interval_sec * 1000), (int) (self->interval_sec * 1000000));
        
      printf("\r\n\r\n");
    }
    printcnt = (printcnt >= printcnt_lim) ? 0 : printcnt+1;

  =}


}
    /*
    for (int i=7; i<14; i++) {
      self->qdec_pos_last_[i-7] = self->qdec_pos_[i-7]; // save last position
      self->qdec_pos_[i-7] = ((float) (count[i])) * self->qdec_convert_motor_to_rad_[i-7]; // update the new position
      self->qdec_vel_est_[i-7] = (self->qdec_pos_[i-7] - self->qdec_pos_last_[i-7]) / (self->interval_sec); //(interval_sec); // estimate velocity from different of positions over the time between positions

      lf_set(qdec_out[i-7],  self->qdec_pos_[i-7]); // should be units of radians
      lf_set(qdec_vel_out[i-7],  self->qdec_vel_est_[i-7]); // should be units of radians per second
    }
    */