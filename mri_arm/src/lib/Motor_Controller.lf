target C {
  single-threaded: true,
  platform: {
    name: "STM32",
    board: "F446RE"
  }
}


// import FFBController from "Joint_Controllers/FFB.lf"
// import PIDController from "Joint_Controllers/PID.lf"
// import Diff_Drive from "Joint_Controllers/Diff_Drive.lf"
import SEAController from "Joint_Controllers/SEA.lf"
import Diff_Motor from "Joint_Controllers/Diff_Motor.lf"
import Diff_Joint from "Joint_Controllers/Diff_Joint.lf"
import PIDControllerGeneric from "Joint_Controllers/PID_Generic.lf"

preamble {=
  #include <stdio.h>
  #include "stm32f4xx_hal.h"
  //#include "stm32_startup.h"
  #include "main.h"
  #include <../../../sm_config.h>

  #define PRINT_MOTOR_CONTROLLER 0
  //state print_motor_controller: bool = true

  /*
  #ifndef __MOTOR_MODE_ENUM
  #define __MOTOR_MODE_ENUM

  // Set Motor Mode -> velocity or position control
  typedef enum {
      MODE_POS = 0U,
      MODE_VEL = 1U,
    } MOTOR_MODE;
  

  // Set Target Mode -> Internal or external control
  typedef enum {
      MODE_INT = 0U,
      MODE_EXT = 1U,
    } TARGET_SRC;

  #endif // __MOTOR_MODE_ENUM
  */

=}

// Import and/or declare reactor classes.
reactor MotorController(refresh_period: time = 10 ms) {
  input enable_motor_command: bool

  input[7] target_sel: MOTOR_MODE

  input[7] target_vel_int: float
  input[7] target_vel_ext: float
  input[7] target_pos_int: float
  input[7] target_pos_ext: float

  input[7] sea_offset: float
  input[7] sea_lim: float

  input[7] qdec_pos: float
  input[7] qdec_vel: float
  
  input[7] qdec_sea: float

  input target_mode: TARGET_SRC

  output[7] speed: float
  output[7] current_joint: float
  output[7] current_joint_sea: float
  

  state target_vel: float[7] = {0, 0, 0, 0, 0, 0, 0}
  state target_pos: float[7] = {0, 0, 0, 0, 0, 0, 0}

  state target_joint_speeds: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control
  //state controller_joint_speeds: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control
  state target_motor_speeds: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control

  state speed_spc: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control
  state speed_posc: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for position control

  state _target_mode: TARGET_SRC = 0
  state _enable_motor_command: bool = false
  state _target_sel: MOTOR_MODE[7] = {1, 1, 1, 1, 1, 1, 1}

  

  timer trigger(0, refresh_period)

  // define reactors 
  control_u0 = new SEAController()

  control_j0 = new Diff_Joint(motor_ID0=1, motor_ID1=2)
  control_j1 = new Diff_Joint(motor_ID0=3, motor_ID1=4)
  control_j2 = new Diff_Joint(motor_ID0=5, motor_ID1=6)
    
  // Feed in the current positions
  qdec_pos ->
    control_u0.current_pos,
    control_j0.current_pos,
    control_j1.current_pos,
    control_j2.current_pos

  // feed in the SEA positions
  qdec_sea ->
    control_u0.sea_pos,
    control_j0.sea_pos,
    control_j1.sea_pos,
    control_j2.sea_pos
    
  control_u0.pos_joint, 
  control_j0.pos_joint, 
  control_j1.pos_joint,
  control_j2.pos_joint 
    -> current_joint
  
  control_u0.pos_sea, 
  control_j0.pos_sea, 
  control_j1.pos_sea,
  control_j2.pos_sea 
    -> current_joint_sea

  sea_offset ->
    control_u0.sea_offset,
    control_j0.sea_offset,
    control_j1.sea_offset,
    control_j2.sea_offset

  sea_lim ->
    control_u0.sea_lim,
    control_j0.sea_lim,
    control_j1.sea_lim,
    control_j2.sea_lim

  preamble{=
    bool use_diff_vel_ext = true; // move this to an input/state
    bool use_motor_configs = false; // get rid of this asap, just for testings
    =}
    
  method convertJointToMotorSpeeds(): void {=
    // apply jacobian
    self->target_motor_speeds[0] = self->target_joint_speeds[0];
    // for diff motors, w0 = pitch + roll, w1 = -pitch + roll
    self->target_motor_speeds[1] =  (self->target_joint_speeds[1] + self->target_joint_speeds[2]); // pitch + roll
    self->target_motor_speeds[2] = (-self->target_joint_speeds[1] + self->target_joint_speeds[2]); // -pitch + roll

    self->target_motor_speeds[3] =  (self->target_joint_speeds[3] + self->target_joint_speeds[4]); // pitch + roll
    self->target_motor_speeds[4] = (-self->target_joint_speeds[3] + self->target_joint_speeds[4]); // -pitch + roll

    self->target_motor_speeds[5] =  (self->target_joint_speeds[5] + self->target_joint_speeds[6]); // pitch + roll
    self->target_motor_speeds[6] = (-self->target_joint_speeds[5] + self->target_joint_speeds[6]); // -pitch + roll

    // apply gear reductions
    for (int i = 0; i<7; i++){
      self->target_motor_speeds[i] = self->target_motor_speeds[i] * motor_configs[i]->gear_ratio * motor_configs[i]->dir;
    }
  =}

  reaction(startup) -> control_u0.constants{=
    // Control Constants [Kp, Kd, Ki]
    lf_set(control_u0.constants[0], joint_configs[0]-> Kp);
    lf_set(control_u0.constants[1], joint_configs[0]-> Kd);
    lf_set(control_u0.constants[2], 0);
    lf_set(control_u0.constants[3], joint_configs[0]-> Ks);
  =}


  // +----------------------------------------------------------------+
  // | MUX between the different target modes
  // +----------------------------------------------------------------+
  reaction(target_vel_int) {=
    //printf("target_vel_ext reaction triggered!\r\n");
    if (self->_target_mode == MODE_INT) {
      for(int i=0; i<7; i++){
        self->speed_spc[i] = target_vel_int[i]->value;
      }
    }
  =}

  // inputs are the targets for the joints, outputs are the motor commands based on the differential joint kinematics
  // jacobian for motors -> joints is [[0.5, -0.5], [0.5, 0.5]], inv for joints -> motors (this case) is [[1, 1], [-1, 1]]. assumes counterclockwise positive for both motors pointing in towards the center.
  reaction(target_vel_ext) {=
    // save target_joint_speeds from the input
    if (self->_target_mode == MODE_EXT) {
      for (int i = 0; i<7; i++)
        self->target_joint_speeds[i] = target_vel_ext[i]->value;
      }

      // TODO: Replace the rest of this method when the PID controller is implimented for external velocity commands.
      convertJointToMotorSpeeds();

      for (int i = 0; i<7; i++){
        self->speed_spc[i] = self->target_motor_speeds[i];
      }
      /*
      if (use_diff_vel_ext){
        if (use_motor_configs){
          self->speed_spc[0] = target_vel_ext[0]->value * (motor_configs[0]->dir);
          // for diff motors, w0 = pitch + roll, w1 = -pitch + roll
          self->speed_spc[1] =  (target_vel_ext[1]->value + target_vel_ext[2]->value) * (motor_configs[1]->dir); // pitch + roll
          self->speed_spc[2] = (-target_vel_ext[1]->value + target_vel_ext[2]->value) * (motor_configs[2]->dir); // -pitch + roll

          self->speed_spc[3] =  (target_vel_ext[3]->value + target_vel_ext[4]->value) * (motor_configs[3]->dir); // pitch + roll
          self->speed_spc[4] = (-target_vel_ext[3]->value + target_vel_ext[4]->value) * (motor_configs[4]->dir); // -pitch + roll

          self->speed_spc[5] =  (target_vel_ext[5]->value + target_vel_ext[6]->value) * (motor_configs[5]->dir); // pitch + roll
          self->speed_spc[6] = (-target_vel_ext[5]->value + target_vel_ext[6]->value) * (motor_configs[6]->dir); // -pitch + roll
        } else{
          self->speed_spc[0] = target_vel_ext[0]->value;
          self->speed_spc[1] =  (target_vel_ext[1]->value + target_vel_ext[2]->value); // pitch + roll
          self->speed_spc[2] = (-target_vel_ext[1]->value + target_vel_ext[2]->value); // -pitch + roll

          self->speed_spc[3] =  (target_vel_ext[3]->value + target_vel_ext[4]->value); // pitch + roll
          self->speed_spc[4] = (-target_vel_ext[3]->value + target_vel_ext[4]->value); // -pitch + roll

          self->speed_spc[5] =  (target_vel_ext[5]->value + target_vel_ext[6]->value); // pitch + roll
          self->speed_spc[6] = (-target_vel_ext[5]->value + target_vel_ext[6]->value); // -pitch + roll
        }
          else {
        for(int i=0; i<7; i++){
            self->speed_spc[i] = target_vel_ext[i]->value;
          }
      }
      */
        /* // for reference
        for (int i=1; i<7; i=i+2){
            self->speed_spc[i] = (target_vel_ext[i+1]->value + target_vel_ext[i]->value) * (motor_configs[i]->dir);
            self->speed_spc[i] = (-target_vel_ext[i+1]->value + target_vel_ext[i+1]->value) * (motor_configs[i+1]->dir);
        }*/
  =}

  reaction(target_pos_int) {=
    if (self->_target_mode == MODE_INT) {
      for(int i=0; i<7; i++) {
        self->target_pos[i] = target_pos_int[i]->value;
      }
    }
  =}

  reaction(target_pos_ext) {=
    if(self->_target_mode == MODE_EXT) {
      for(int i=0; i<7; i++){
        self->target_pos[i] = target_pos_ext[i]->value;
      }
    }
  =}

  // +----------------------------------------------------------------+


  // +----------------------------------------------------------------+
  // | Use targets to get desired speeds
  // +----------------------------------------------------------------+
  reaction(trigger) -> 
      control_u0.target_pos,
      control_j0.target_joint,
      control_j1.target_joint,
      control_j2.target_joint
      {=
    // printf("UPDATE VAL: %d\r\n", (int)(100 * self->target_pos[5]));
    lf_set(control_u0.target_pos,      self->target_pos[0]);
    lf_set(control_j0.target_joint[0], self->target_pos[1]);
    lf_set(control_j0.target_joint[1], self->target_pos[2]);
    lf_set(control_j1.target_joint[0], self->target_pos[3]);
    lf_set(control_j1.target_joint[1], self->target_pos[4]);
    lf_set(control_j2.target_joint[0], self->target_pos[5]);
    lf_set(control_j2.target_joint[1], self->target_pos[6]);
    
  =}

  // Read out the positional control speed values
  reaction(
      control_j0.speed_out,
      control_j1.speed_out,
      control_j2.speed_out,
      control_u0.out) {=
    self -> speed_posc[0] = control_u0.out->value;
    self -> speed_posc[1] = control_j0.speed_out[0]->value;
    self -> speed_posc[2] = control_j0.speed_out[1]->value;
    self -> speed_posc[3] = control_j1.speed_out[0]->value;
    self -> speed_posc[4] = control_j1.speed_out[1]->value;
    self -> speed_posc[5] = control_j2.speed_out[0]->value;
    self -> speed_posc[6] = control_j2.speed_out[1]->value;
    
  =}

  reaction(
      control_u0.out,
      control_j0.speed_out,
      control_j1.speed_out,
      control_j2.speed_out) {=
    self -> speed_posc[0] = control_u0.out->value;
    self -> speed_posc[1] = control_j0.speed_out[0]->value;
    self -> speed_posc[2] = control_j0.speed_out[1]->value;
    self -> speed_posc[3] = control_j1.speed_out[0]->value;
    self -> speed_posc[4] = control_j1.speed_out[1]->value;
    self -> speed_posc[5] = control_j2.speed_out[0]->value;
    self -> speed_posc[6] = control_j2.speed_out[1]->value;
    
  =}

  reaction(enable_motor_command) {=
    bool old_motor_command_bool = self->_enable_motor_command;
    self->_enable_motor_command = enable_motor_command->value;
    if (PRINT_MOTOR_CONTROLLER) printf("enable_motor_command reaction called, setting value to from %d to new value of %d from input %d\r\n", old_motor_command_bool, self->_enable_motor_command, enable_motor_command->value);

  =}

  reaction(target_mode) {=
    self->_target_mode = target_mode->value;
    if (PRINT_MOTOR_CONTROLLER) printf("target_mode reaction called, setting value to %d from input %d\r\n",  self->_target_mode, target_mode->value);
  =}

  reaction(target_sel) {=
    int old_motor_command = 0;
    for (int i = 0; i<7; i++){
      old_motor_command = self->_target_sel[i];
      self->_target_sel[i] = target_sel[i]->value;
      if (PRINT_MOTOR_CONTROLLER) printf("target_sel reaction called, setting value to from %d to new value of %d from input %d\r\n", old_motor_command,  self->_target_sel[i], target_sel[i]->value);
    }
  =}

  // +----------------------------------------------------------------+
  // | Set speed output
  // +----------------------------------------------------------------+
  reaction(trigger) -> speed{=
    if (self->_enable_motor_command){
      // We use this to set either the speed or position of the motors
      if (PRINT_MOTOR_CONTROLLER) {printf("Motor_Controller: Setting speeds of: ");}
        for(int i=0; i<7; i++){
          if ((self->_target_sel[i] == MODE_POS)){
            lf_set(speed[i], self->speed_posc[i]);
          }
          else if((self->_target_sel[i] == MODE_VEL)){
            if (PRINT_MOTOR_CONTROLLER) {printf("%d,", (int)(self->speed_spc[i] * 1000));}
            lf_set(speed[i], self->speed_spc[i]);
          }
          else{
            printf("Received bad target_sel! Got %d, expected %d or %d. Not sending!", self->_target_sel[i], MODE_POS, MODE_VEL);
          }
      // lf_set(speed[i], (target_sel[i]->value == MODE_POS)? self->speed_posc[i]: self->speed_spc[i]);
      }
      if (PRINT_MOTOR_CONTROLLER) printf("\r\n");
  }
  else{
    //printf("_enable_motor_command is off!\r\n");
  }
  
    // consider adding an else statement to force velocity control and set the target velocities to zero. Mode_Machine should do that anyways.
  =}
}