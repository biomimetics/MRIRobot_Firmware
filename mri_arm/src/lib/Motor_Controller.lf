target C {
  single-threaded: true,
  platform: {
    name: "STM32",
    board: "F446RE"
  }
}


// import FFBController from "Joint_Controllers/FFB.lf"
// import PIDController from "Joint_Controllers/PID.lf"
// import Diff_Drive from "Joint_Controllers/Diff_Drive.lf"
import SEAController from "Joint_Controllers/SEA.lf"
import Diff_Motor from "Joint_Controllers/Diff_Motor.lf"
import Diff_Joint from "Joint_Controllers/Diff_Joint.lf"
import PIDControllerGeneric from "Joint_Controllers/PID_Generic.lf"

preamble {=
  #include <stdio.h>
  #include "stm32f4xx_hal.h"
  //#include "stm32_startup.h"
  #include "main.h"
  #include <../../../sm_config.h>

  #define PRINT_MOTOR_CONTROLLER 0
  //state print_motor_controller: bool = true

  #define USE_CLOSED_LOOP_VELOCITY 1
  #define USE_FEEDFORWARD_VELOCITY 1

  #ifndef __CONTROLLER_CONFIG
  #define __CONTROLLER_CONFIG

  typedef struct {
    float Kp;                     // proportional control gain
    float Kd;                     // differential control gain
    float Ki;                     // integral control gain
    float integral_clamping_max;  // maximum intergral control signal
    float control_signal_max;     // maximum control signal
   } pid_config;

  static pid_config vel_pid_config_0 = {
    1.0,
    0.1,
    0.0,
    10.0,
    10.0 
  };
   //Kp = 1.0, Kd = 0.1, Ki = 0.0, CONTROL_LIMIT = 5.0, INTEGRAL_CLAMPING_MAX = 1.0
  #endif // __CONTROLLER_CONFIG


=}

// Import and/or declare reactor classes.
reactor MotorController(refresh_period: time = 10 ms) {
  input enable_motor_command: bool

  input[7] target_sel: MOTOR_MODE

  input[7] target_vel_int: float
  input[7] target_vel_ext: float
  input[7] target_pos_int: float
  input[7] target_pos_ext: float

  input[7] sea_offset: float
  input[7] sea_lim: float

  input[7] qdec_pos: float
  input[7] qdec_vel: float
  
  input[7] qdec_sea: float

  input target_mode: TARGET_SRC

  output[7] speed: float
  output[7] current_joint: float
  output[7] current_joint_sea: float
  
  preamble{=
    bool use_diff_vel_ext = true; // move this to an input/state
    //static Timer_State timer_st_u5 = {0, 0.005};
    =}
    
  state target_vel: float[7] = {0, 0, 0, 0, 0, 0, 0}
  state target_pos: float[7] = {0, 0, 0, 0, 0, 0, 0}

  state target_joint_speeds: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control
  //state controller_joint_speeds: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control
  state target_motor_speeds: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control

  state speed_spc: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for velocity control
  state speed_posc: float[7] = {0, 0, 0, 0, 0, 0, 0} // speed for position control

  state _target_mode: TARGET_SRC = 0
  state _enable_motor_command: bool = false
  state _target_sel: MOTOR_MODE[7] = {1, 1, 1, 1, 1, 1, 1}

  //state timer_st_u5: Timer_Struct = {0, 0.005}
  

  timer trigger(0, refresh_period)

  // POSITION CONTROLLERS 
  // define reactors 
  control_u0 = new SEAController()
  control_j0 = new Diff_Joint(motor_ID0=1, motor_ID1=2)
  control_j1 = new Diff_Joint(motor_ID0=3, motor_ID1=4)
  control_j2 = new Diff_Joint(motor_ID0=5, motor_ID1=6)
    
  // Feed in the current positions
  qdec_pos ->
    control_u0.current_pos,
    control_j0.current_pos,
    control_j1.current_pos,
    control_j2.current_pos

  // feed in the SEA positions
  qdec_sea ->
    control_u0.sea_pos,
    control_j0.sea_pos,
    control_j1.sea_pos,
    control_j2.sea_pos
    
  control_u0.pos_joint, 
  control_j0.pos_joint, 
  control_j1.pos_joint,
  control_j2.pos_joint 
    -> current_joint
  
  control_u0.pos_sea, 
  control_j0.pos_sea, 
  control_j1.pos_sea,
  control_j2.pos_sea 
    -> current_joint_sea

  sea_offset ->
    control_u0.sea_offset,
    control_j0.sea_offset,
    control_j1.sea_offset,
    control_j2.sea_offset

  sea_lim ->
    control_u0.sea_lim,
    control_j0.sea_lim,
    control_j1.sea_lim,
    control_j2.sea_lim

  // ######
  // ### VELOCITY CONTROLLERS

  
  
  // reactor PIDControllerGeneric(Kp:float=0.0, Kd:float=0.0, Ki:float=0.0, CONTROL_LIMIT:float=1.0, INTEGRAL_CLAMPING_MAX:float=0.0)
  vcontrol_u0 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)
  vcontrol_u1 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)
  vcontrol_u2 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)
  vcontrol_u3 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)
  vcontrol_u4 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)
  vcontrol_u5 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)
  vcontrol_u6 = new PIDControllerGeneric(Kp = 0.1, Kd = 0.0001, Ki = 0.001, CONTROL_LIMIT = 50.0, INTEGRAL_CLAMPING_MAX = 1.0)

  
  qdec_vel ->
    vcontrol_u0.current_state,
    vcontrol_u1.current_state,
    vcontrol_u2.current_state,
    vcontrol_u3.current_state,
    vcontrol_u4.current_state,
    vcontrol_u5.current_state,
    vcontrol_u6.current_state
  

    
  method convertJointToMotorSpeeds(): void {=
    // apply jacobian
    self->target_motor_speeds[0] = self->target_joint_speeds[0];
    // for diff motors, w0 = pitch + roll, w1 = -pitch + roll
    self->target_motor_speeds[1] =  (self->target_joint_speeds[1] + self->target_joint_speeds[2]); // pitch + roll
    self->target_motor_speeds[2] = (-self->target_joint_speeds[1] + self->target_joint_speeds[2]); // -pitch + roll

    self->target_motor_speeds[3] =  (self->target_joint_speeds[3] + self->target_joint_speeds[4]); // pitch + roll
    self->target_motor_speeds[4] = (-self->target_joint_speeds[3] + self->target_joint_speeds[4]); // -pitch + roll

    self->target_motor_speeds[5] =  (self->target_joint_speeds[5] + self->target_joint_speeds[6]); // pitch + roll
    self->target_motor_speeds[6] = (-self->target_joint_speeds[5] + self->target_joint_speeds[6]); // -pitch + roll

  =}

  reaction(startup) -> control_u0.constants{=
    // Control Constants [Kp, Kd, Ki]
    lf_set(control_u0.constants[0], joint_configs[0]-> Kp);
    lf_set(control_u0.constants[1], joint_configs[0]-> Kd);
    lf_set(control_u0.constants[2], 0);
    lf_set(control_u0.constants[3], joint_configs[0]-> Ks);
  =}


  // +----------------------------------------------------------------+
  // | MUX between the different target modes
  // +----------------------------------------------------------------+
  reaction(target_vel_int) {=
    //printf("target_vel_ext reaction triggered!\r\n");
    if (self->_target_mode == MODE_INT) {
      for(int i=0; i<7; i++){
        //self->speed_spc[i] = target_vel_int[i]->value;
        self->target_motor_speeds[i] = target_vel_int[i]->value; // sets them directly here, motor by motor, no joint
        //printf("%d ", ((int)(self->target_motor_speeds[i] * 1000.0))); this is happening and these values are being set...
      }
    }
  =}

  // inputs are the targets for the joints, outputs are the motor commands based on the differential joint kinematics
  // jacobian for motors -> joints is [[0.5, -0.5], [0.5, 0.5]], inv for joints -> motors (this case) is [[1, 1], [-1, 1]]. assumes counterclockwise positive for both motors pointing in towards the center.
  reaction(target_vel_ext) {=
    // save target_joint_speeds from the input
    if (self->_target_mode == MODE_EXT) {
      for (int i = 0; i<7; i++){
        self->target_joint_speeds[i] = target_vel_ext[i]->value;
      }
      convertJointToMotorSpeeds(); // putting this here allows for homing to work...
    }
    //convertJointToMotorSpeeds(); // sets target_motor_speeds internally

      
      
  =}

  // +----------------------------------------------------------------+
  // | Use targets to get desired speeds
  // +----------------------------------------------------------------+
  reaction(trigger) -> 
      control_u0.target_pos,
      control_j0.target_joint,
      control_j1.target_joint,
      control_j2.target_joint,
      vcontrol_u0.target_state,
      vcontrol_u1.target_state,
      vcontrol_u2.target_state,
      vcontrol_u3.target_state,
      vcontrol_u4.target_state,
      vcontrol_u5.target_state,
      vcontrol_u6.target_state
      {=
    // printf("UPDATE VAL: %d\r\n", (int)(100 * self->target_pos[5]));
    lf_set(control_u0.target_pos,      self->target_pos[0]);
    lf_set(control_j0.target_joint[0], self->target_pos[1]);
    lf_set(control_j0.target_joint[1], self->target_pos[2]);
    lf_set(control_j1.target_joint[0], self->target_pos[3]);
    lf_set(control_j1.target_joint[1], self->target_pos[4]);
    lf_set(control_j2.target_joint[0], self->target_pos[5]);
    lf_set(control_j2.target_joint[1], self->target_pos[6]);

    if (USE_CLOSED_LOOP_VELOCITY){
        lf_set(vcontrol_u0.target_state, self->target_motor_speeds[0]);
        lf_set(vcontrol_u1.target_state, self->target_motor_speeds[1]);
        lf_set(vcontrol_u2.target_state, self->target_motor_speeds[2]);
        lf_set(vcontrol_u3.target_state, self->target_motor_speeds[3]);
        lf_set(vcontrol_u4.target_state, self->target_motor_speeds[4]);
        lf_set(vcontrol_u5.target_state, self->target_motor_speeds[5]);
        lf_set(vcontrol_u6.target_state, self->target_motor_speeds[6]);
        /*
        lf_set(vcontrol_u0.target_state, self->target_joint_speeds[0]);
        lf_set(vcontrol_u1.target_state, self->target_joint_speeds[1]);
        lf_set(vcontrol_u2.target_state, self->target_joint_speeds[2]);
        lf_set(vcontrol_u3.target_state, self->target_joint_speeds[3]);
        lf_set(vcontrol_u4.target_state, self->target_joint_speeds[4]);
        lf_set(vcontrol_u5.target_state, self->target_joint_speeds[5]);
        lf_set(vcontrol_u6.target_state, self->target_joint_speeds[6]);
        */
      }
      else {
        for (int i = 0; i<7; i++){
          self->speed_spc[i] = self->target_motor_speeds[i];
        }
      }
  =}

  reaction(target_pos_int) {=
    if (self->_target_mode == MODE_INT) {
      for(int i=0; i<7; i++) {
        self->target_pos[i] = target_pos_int[i]->value;
      }
    }
  =}

  reaction(target_pos_ext) {=
    if(self->_target_mode == MODE_EXT) {
      for(int i=0; i<7; i++){
        self->target_pos[i] = target_pos_ext[i]->value;
      }
    }
  =}

  // +----------------------------------------------------------------+


  

  // Read out the positional control speed values
  reaction(
      control_j0.speed_out,
      control_j1.speed_out,
      control_j2.speed_out,
      control_u0.out) {=
    self -> speed_posc[0] = control_u0.out->value;
    self -> speed_posc[1] = control_j0.speed_out[0]->value;
    self -> speed_posc[2] = control_j0.speed_out[1]->value;
    self -> speed_posc[3] = control_j1.speed_out[0]->value;
    self -> speed_posc[4] = control_j1.speed_out[1]->value;
    self -> speed_posc[5] = control_j2.speed_out[0]->value;
    self -> speed_posc[6] = control_j2.speed_out[1]->value;
    
  =}

  reaction(
      control_u0.out,
      control_j0.speed_out,
      control_j1.speed_out,
      control_j2.speed_out) {=
    self -> speed_posc[0] = control_u0.out->value;
    self -> speed_posc[1] = control_j0.speed_out[0]->value;
    self -> speed_posc[2] = control_j0.speed_out[1]->value;
    self -> speed_posc[3] = control_j1.speed_out[0]->value;
    self -> speed_posc[4] = control_j1.speed_out[1]->value;
    self -> speed_posc[5] = control_j2.speed_out[0]->value;
    self -> speed_posc[6] = control_j2.speed_out[1]->value;
    
  =}

  // Read out the positional control speed values
  reaction(
      vcontrol_u0.control_signal,
      vcontrol_u1.control_signal,
      vcontrol_u2.control_signal,
      vcontrol_u3.control_signal,
      vcontrol_u4.control_signal,
      vcontrol_u5.control_signal,
      vcontrol_u6.control_signal) {=
    self->speed_spc[0] = vcontrol_u0.control_signal->value;
    self->speed_spc[1] = vcontrol_u1.control_signal->value;
    self->speed_spc[2] = vcontrol_u2.control_signal->value;
    self->speed_spc[3] = vcontrol_u3.control_signal->value;
    self->speed_spc[4] = vcontrol_u4.control_signal->value;
    self->speed_spc[5] = vcontrol_u5.control_signal->value;
    self->speed_spc[6] = vcontrol_u6.control_signal->value;

    if (USE_FEEDFORWARD_VELOCITY){
      for (int i = 0; i<7; i++){
        self->speed_spc[i] += self->target_motor_speeds[i]; 
      }
    }
  =}

  reaction(enable_motor_command) {=
    bool old_motor_command_bool = self->_enable_motor_command;
    self->_enable_motor_command = enable_motor_command->value;
    if (PRINT_MOTOR_CONTROLLER) printf("enable_motor_command reaction called, setting value to from %d to new value of %d from input %d\r\n", old_motor_command_bool, self->_enable_motor_command, enable_motor_command->value);

  =}

  reaction(target_mode) {=
    self->_target_mode = target_mode->value;
    if (PRINT_MOTOR_CONTROLLER) printf("target_mode reaction called, setting value to %d from input %d\r\n",  self->_target_mode, target_mode->value);
  =}

  reaction(target_sel) {=
    int old_motor_command = 0;
    for (int i = 0; i<7; i++){
      old_motor_command = self->_target_sel[i];
      self->_target_sel[i] = target_sel[i]->value;
      if (PRINT_MOTOR_CONTROLLER) printf("target_sel reaction called, setting value to from %d to new value of %d from input %d\r\n", old_motor_command,  self->_target_sel[i], target_sel[i]->value);
    }
  =}

  // +----------------------------------------------------------------+
  // | Set speed output
  // +----------------------------------------------------------------+
  reaction(trigger) -> speed{=
    if (self->_enable_motor_command){
      // We use this to set either the speed or position of the motors
      if (PRINT_MOTOR_CONTROLLER) {printf("Motor_Controller: Setting speeds of: ");}
        for(int i=0; i<7; i++){
          if ((self->_target_sel[i] == MODE_POS)){
            lf_set(speed[i], self->speed_posc[i]);
          }
          else if((self->_target_sel[i] == MODE_VEL)){
            if (PRINT_MOTOR_CONTROLLER) {printf("v%d, ", (int)(self->speed_spc[i] * 1000));}
            lf_set(speed[i], self->speed_spc[i]);
          }
          else{
            printf("Received bad target_sel! Got %d, expected %d or %d. Not sending!", self->_target_sel[i], MODE_POS, MODE_VEL);
          }
      // lf_set(speed[i], (target_sel[i]->value == MODE_POS)? self->speed_posc[i]: self->speed_spc[i]);
      }
      if (PRINT_MOTOR_CONTROLLER) printf("\r\n");
  }
  else{
    //printf("_enable_motor_command is off!\r\n");
  }
  
    // consider adding an else statement to force velocity control and set the target velocities to zero. Mode_Machine should do that anyways.
  =}
}