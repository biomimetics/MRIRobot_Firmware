target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  //#include "stm32_startup.h"
  #include "main.h"
  #include <stdio.h>

  #include <../../../motor_config.h>
  #include <../../../joint_config.h>
  #include <../../../sm_config.h>

  #define DMA_TX_BUFFER_SIZE 60
  #define DMA_RX_BUFFER_SIZE 60
  #define DMA_RECEIVE_SIZE 15
  //#define DMA_UART huart6 // was huart1
=}

reactor ROSInterface (send_period: time = 20 ms, recieve_period: time = 20 ms){
  //input[7] current_pos: float // unused!
  //input[7] joint_pos: float // unused!
  //input[7] sea_pos: float // unused!
  //output[7] target_state: int // unused!

  //inputs from motor controller to send back to ROS
  input[7] current_joint: float // position of joints from usm encoders
  input[7] current_joint_sea: float // position of seas from sea encoders

  //input[7] current_joint_vel: float // position of joints from usm encoders

  // outputs for sending to motor controller
  output[7] target_pos_ext: float
  output[7] target_vel_ext: float

  output[7] sea_offset: float
  output[7] sea_lim: float

  // outputs for sending state changes
  output set_mode_change: MODE_ENUM


  // trigger timers
  timer trigger_send(0 ms, send_period) // unused!
  timer trigger_update(0 ms, recieve_period)
  timer trigger_test(0 ms, 2000 ms)

  timer timer_idle_reset(0 ms, 100 ms)
  state set_command_failed_counter: int = 0 //
  state set_command_failed_counter_max: int = 20 // TODO: 20 counts * 20ms period should be about 1s if the clock is good enough. Replace this with a real timer asap!
  state last_mode_change: MODE_ENUM = 0 // idle

  state scaled_joint_pos: float[7] = {0, 0, 0, 0, 0, 0, 0}
  state scaled_joint_vel: float[7] = {0, 0, 0, 0, 0, 0, 0}
  state scaled_sea_offset: float[7] = {0, 0, 0, 0, 0, 0, 0}
  state scaled_sea_lim: float[7] = {1000, 1000, 1000, 1000, 1000, 1000, 1000}

  // Data in format:      'p' + 6x[fp32] -> 25 bytes
  // Data out format:     'e' + 6x[fp32] -> 25 bytes
  preamble {=

    extern UART_HandleTypeDef huart1;        // usb-c tied uart for computer communication
    extern UART_HandleTypeDef huart4; // used for ROS interface
    extern UART_HandleTypeDef huart6; // used for ROS interface if huart4 is misbehaving

    extern DMA_HandleTypeDef hdma_usart1_rx;
    extern DMA_HandleTypeDef hdma_usart1_tx;

    static int print_ros = true;

    // Setup Rx and Tx buffers
    //static uint16_t dma_receive_size = 15; // moved to preprocessor define statement

    static uint8_t rx_buffer[DMA_RX_BUFFER_SIZE];
    uint8_t rx_copy_buffer[DMA_RX_BUFFER_SIZE]; // used for storing internal copy of the rx_buffer
    uint8_t rx_command_buffer[DMA_RX_BUFFER_SIZE]; // used for staging a change of command

    static uint8_t tx_buffer[DMA_TX_BUFFER_SIZE];

    uint16_t RxDataLen = 0; // received data length set by ReceiveToIdle_IT's callback
    bool flag_receive_to_idle_events_not_yet_triggered = true; // unused!
    bool flag_handshake_success = false; // unused!
    bool flag_new_command_received = false;

    float joint_dir[7]= {1, 1, 1, 1, 1, -1, -1}; // why are both of these defined and used in different functions?
    float dir_offsets[7]= {1, 1, 1, 1, 1, -1, -1};
    int loopback_offset[7]= {0, 0, 0, 0, 0, 0, 0};

    int enc_data[7];
    int sea_data[7];

    // We have an inFlight indicator if the DMA is currently sending data
    static volatile int inFlight = 0;

    bool flag_update_set_mode_change = false;
    int desired_state = 0;

    // +---------------------------------------------------+
    // | Init functions
    // +---------------------------------------------------+
    void configure_gpio_switch_pins(){
      /* Configure Switch pins : PC1 */
      GPIO_InitTypeDef GPIO_InitStruct = {0};
      __HAL_RCC_GPIOH_CLK_ENABLE();
      __HAL_RCC_GPIOC_CLK_ENABLE();
      GPIO_InitStruct.Pin = GPIO_PIN_1;
      GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

      HAL_GPIO_WritePin(GPIOH, GPIO_PIN_1, GPIO_PIN_RESET);
      GPIO_InitStruct.Pin = GPIO_PIN_1;
      GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
      GPIO_InitStruct.Pull = GPIO_NOPULL;
      GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
      HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
    }

    // +---------------------------------------------------+
    // | Helper functions
    // +---------------------------------------------------+

    // UNUSED!
    static float get_target(uint8_t* data) {
      float count = data[0] + (data[1]<<8) + (data[2]<<16) + (data[3]<<24) + (data[4]<<32);
      return count;
    }

    void print_resp(float* data) {
      printf("      [%d, %d, %d, %d, %d, %d, %d]\r\n", 
                        (int)(data[0]*1000), (int)(data[1]*1000), (int)(data[2]*1000), (int)(data[3]*1000), 
                        (int)(data[4]*1000), (int)(data[5]*1000), (int)(data[6]*1000));
    }

    float uncompress_data(uint8_t lower, uint8_t upper) {
      return ((float) ((int16_t)lower  + (int16_t)(upper<<8)))/1000.0;
    }

    // assumes that the checksum_index is the last byte in the message
    bool checkChecksum(uint8_t* buffer, int msg_size){
      //uint8_t rx_buffer[60]; // recieving buffer
      int computed_checksum = 0;
      for (int i = 0; i < msg_size-2; i++){
        computed_checksum += buffer[i];
      }
      computed_checksum = computed_checksum % 256;
      if (computed_checksum == buffer[msg_size-1]){
        return true;
      }
      else {
        printf("Checksum failed! Expected %d for msg_size %d, but computed %d.", buffer[msg_size-1], msg_size, computed_checksum);
        return false;
      }
    }

    // +---------------------------------------------------+
    // | UART DMA Callback functions
    // +---------------------------------------------------+

    // UART receive callback
    void HAL_UART_RxCallback1(){
      //printf("In HAL_UART_RxCallback1");
    } // this needs to be defined to build correctly, check to make sure this is ok

    void HAL_UARTEx_RxEventCallback(UART_HandleTypeDef *huart, uint16_t Size){
      //printf("In HAL_UARTEx_RxEventCallback\r\n");
      //printf("rx_buffer before memmove: %s\r\n", rx_buffer);
      //printf("rx_copy_buffer before memmove %s\r\n", rx_copy_buffer);
      //printf("rx_buffer after memmove: %s\r\n", rx_buffer);
      //printf("rx_copy_buffer after memmove: %s\r\n", rx_copy_buffer);

      bool checksum_valid = false;
      RxDataLen = Size; // RxDataLen is the size of the received data

      memmove(rx_copy_buffer, rx_buffer, sizeof(rx_buffer)); // copy over the full size of the buffer

      //printf("rx_copy_buffer after memmove: %s\r\n", rx_copy_buffer);

      checksum_valid = checkChecksum(rx_copy_buffer, RxDataLen); // checks if the checksum is valid

      if (checksum_valid){
        //memmove(rx_command_buffer, rx_copy_buffer, sizeof(rx_copy_buffer)); // copy over the full size of the copy buffer to the command buffer
        memmove(rx_command_buffer, rx_copy_buffer, DMA_RX_BUFFER_SIZE); // copy over the full size of the copy buffer to the command buffer
        flag_new_command_received = true; // flag that there's a new command to be processed by a reaction
        //printf("rx_command_buffer after memmove: %s\r\n", rx_command_buffer);
      }
      
      HAL_UARTEx_ReceiveToIdle_DMA(&DMA_UART, rx_buffer, DMA_RX_BUFFER_SIZE);
    }


    // UART transmit callback
    void HAL_UART_TxCallback1() {
      inFlight = 0;
    }

    /*##### 
    # helper functions for handling inputs from ROS connection
    #####*/

    // if new command is avaiable, set the values for it.
    bool set_newest_command(float* joint_pos_array, float* joint_vel_array, float* sea_offset_array) {
      // this function seems to work fine
      if (flag_new_command_received){
        //printf("New command of %s received.\r\n", rx_command_buffer);
        //printf("New copy buffer of %s received.\r\n", rx_copy_buffer);
        //printf("New buffer of %s received.\r\n", rx_buffer);
        if (rx_command_buffer[0] == 'p') {              // Change joint position target
            //set_joint_pos_data();
            set_joint_pos_data(joint_pos_array);
        } 
        else if (rx_command_buffer[0] == 'v') {       // Change joint velocity target
            //set_joint_vel_data();
            set_joint_vel_data(joint_vel_array);
        } 
        else if (rx_command_buffer[0] == 'o') {       // Change joint sea offset
            //set_sea_offset_data();
            set_sea_offset_data(sea_offset_array);
        } 
        else if (rx_command_buffer[0] == 's') {      // Change high level mode
            trigger_mode_change();
        }
        else {
          printf("Got unexpected leading character. Got %c, expected p, v, o, or s.\r\n", rx_command_buffer[0]);
        }
        flag_new_command_received = false; // set it to false after the new command is used.
        return true; // if command is set, return true
      }
      return false; // if commands are not set (not updated or checksums are failing), return false
      
    }

    void handle_usbc_transmit_encoders(){
      int num = sprintf(tx_buffer,"e%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d,%d\r\n", 
            enc_data[0], enc_data[1], enc_data[2], enc_data[3], enc_data[4], enc_data[5], enc_data[6], 
            sea_data[0], sea_data[1], sea_data[2], sea_data[3], sea_data[4], sea_data[5], sea_data[6],
            loopback_offset[0], loopback_offset[1], loopback_offset[2], loopback_offset[3], loopback_offset[4], loopback_offset[5], loopback_offset[6]);
      HAL_UART_Transmit_DMA(&DMA_UART, tx_buffer, num);
    }

    // When the rx_buffer command is a [set joint position] command
    
    void set_joint_pos_data(float* joint_pos_array) {
      for (int i=0; i<7; i++) {
        joint_pos_array[i] = joint_dir[i] * uncompress_data(rx_command_buffer[(i*2)+2], rx_command_buffer[(i*2)+1]);
        //joint_pos_array[i] = joint_dir[i] * uncompress_data(rx_copy_buffer[(i*2)+2], rx_copy_buffer[(i*2)+1]);
      }

      if (print_ros)  {
        printf("got [JOINT POS]: \r\n");
        print_resp(joint_pos_array);
      }
    }

    // When the rx_buffer command is a [set joint velocity] command
    void set_joint_vel_data(float* joint_vel_array) {
      for (int i=0; i<7; i++) {
        joint_vel_array[i] = joint_dir[i] * uncompress_data(rx_command_buffer[(i*2)+2], rx_command_buffer[(i*2)+1]);
        //joint_vel_array[i] = joint_dir[i] * uncompress_data(rx_copy_buffer[(i*2)+2], rx_copy_buffer[(i*2)+1]);
      }

      if (print_ros)  {
        //printf("got [JOINT VEL]: \r\n");
        //print_resp(joint_vel_array);
      }
    }

    // Functions for setting relevant info for seas
    void set_sea_offset_data(float* sea_offset_array) {
      for (int i=0; i<7; i++) {
        if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_1)) {
          sea_offset_array[i] = 0;
          loopback_offset[i] = 0;
        } else {
          sea_offset_array[i] = uncompress_data(rx_command_buffer[(i*2)+2], rx_command_buffer[(i*2)+1]);
          //sea_offset_array[i] = uncompress_data(rx_copy_buffer[(i*2)+2], rx_copy_buffer[(i*2)+1]);
          loopback_offset[i] = (int)(1000 * sea_offset_array[i]);
        }
      }
    }

    // this function assumes rx_buffer[1] has a char for '0', '1', '2', or '3' for now. Consider changing this. Also may need to make this a reactor method.
    void trigger_mode_change() {
      if (rx_command_buffer[1] == '0') { // set mode to idle
        desired_state = 0;
        flag_update_set_mode_change = true;
      } 
      else if (rx_command_buffer[1] == '1') { // set mode to home
        desired_state = 1;
        flag_update_set_mode_change = true;
      } 
      else if (rx_command_buffer[1] == '2') { // set mode to run with position inputs
        desired_state = 2;
        flag_update_set_mode_change = true;
      } 
      else if (rx_command_buffer[1] == '3') { // set mode to run with velocity inputs
        desired_state = 3;
        flag_update_set_mode_change = true;
      }
      else {
        flag_update_set_mode_change = false;
        desired_state = 0;
        printf("!! Invalid desired_state in receive_transmit_update in ROS_Interface.lf !!\r\n");
        printf("trigger_mode_change: Did not receive valid char. Got %c, expected 0, 1, 2, or 3.", rx_command_buffer[1]);
      }
  }

    /*##### 
    # helper functions for testing
    #####*/
    // add test data function to simulate ROS interface
    void RxCallbackTest() {
    }

  =}

  reaction(startup) {=
    // Setup UART interfaces
    // should be done in main.lf

    // Prep ROS bridge DMA recieve
    //HAL_UART_Receive_DMA(&huart1, rx_buffer, 15);
    //printf("ROS_Interface: In startup reaction before HAL_UARTEx_ReceiveToIdle_DMA...\r\n");
    HAL_UARTEx_ReceiveToIdle_DMA(&DMA_UART, rx_buffer, DMA_RX_BUFFER_SIZE);

    

    configure_gpio_switch_pins();
    /* //Configure Switch pins : PC1 
    GPIO_InitTypeDef GPIO_InitStruct = {0};
    __HAL_RCC_GPIOH_CLK_ENABLE();
    __HAL_RCC_GPIOC_CLK_ENABLE();
    GPIO_InitStruct.Pin = GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_INPUT;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    HAL_GPIO_Init(GPIOC, &GPIO_InitStruct);

    HAL_GPIO_WritePin(GPIOH, GPIO_PIN_1, GPIO_PIN_RESET);
    GPIO_InitStruct.Pin = GPIO_PIN_1;
    GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
    HAL_GPIO_Init(GPIOH, &GPIO_InitStruct);
    */

    for (int i=0; i<7; i++) {
      self->scaled_sea_lim[i] = joint_configs[i]->lim;
      self->scaled_sea_offset[i] = 0;
    }
      
  =}

  /*##### 
    # Input reactions
    #####*/

  // Update our current USM position to send to ROS
  reaction(current_joint) {=
    for (int i=0; i<7; i++) {
      enc_data[i] = (int)(current_joint[i]->value * 1000) * dir_offsets[i];
    }
  =}

  // Update our current sea position to send to ROS
  reaction(current_joint_sea) {=
    for (int i=0; i<7; i++) {
      sea_data[i] = (int)(current_joint_sea[i]->value * 1000);
    }
  =}

  /*##### 
    # Output reactions
    #####*/

  reaction send_transmit_update (trigger_send) {=
    // handle sending back robot's encoder state
    //handle_usbc_transmit_encoders();
    =}

  reaction receive_transmit_update (trigger_update) -> set_mode_change, target_pos_ext, target_vel_ext, sea_offset, sea_lim{=

    // sets the internal variables for updating the other reactors. If it's in run mode and there's not a fresh value from ROS, iterate the coutner
    if (!set_newest_command(self->scaled_joint_pos, self->scaled_joint_vel, self->scaled_sea_offset)){
      if ((self->last_mode_change == SET_RUN_POS) || (self->last_mode_change == SET_RUN_VEL)){
        self->set_command_failed_counter += 1;
      }
    }

    // if the coutner's too big, assume ROS isn't working and reset to idle.
    if (self->set_command_failed_counter_max <= self->set_command_failed_counter){
      if ((self->last_mode_change == SET_RUN_POS) || (self->last_mode_change == SET_RUN_VEL)){
        printf("ROS_Interface.lf has not received a valid command for a long time (about 400ms)!\r\n Forcing idle mode switch...\r\n");
        lf_set(set_mode_change, SET_IDLE);
        self->last_mode_change = SET_IDLE;
        self->set_command_failed_counter = 0;
      }
    }

    // handle sending back robot's encoder state
    handle_usbc_transmit_encoders(); // TODO: Find out why this has to be done *after* using rx_command_buffer. Very weird. Breaks everything otherwise.

    // handle mode changes if they occur
    if (flag_update_set_mode_change){
      if (desired_state == 0) { // set mode to idle
        lf_set(set_mode_change, SET_IDLE); // make sure all of these align with defs in mode_enum from sm_config.h!!! 
        self->last_mode_change = SET_IDLE;
      } 
      else if (desired_state == 1) { // set mode to home
        lf_set(set_mode_change, SET_HOMING);
        self->last_mode_change = SET_HOMING;
      } 
      else if (desired_state == 2) { // set mode to run with position inputs
        lf_set(set_mode_change, SET_RUN_POS);
        self->last_mode_change = SET_RUN_POS;
      } 
      else if (desired_state == 3) { // set mode to run with velocity inputs
        lf_set(set_mode_change, SET_RUN_VEL);
        self->last_mode_change = SET_RUN_VEL;
      }
      else {
        printf("Invalid desired_state in receive_transmit_update in ROS_Interface.lf!\r\n");
          printf("Received %d but expected one of 0, 1, 2, or 3\r\n", desired_state);
      }
      flag_update_set_mode_change = false;
    }

    // set target_poisitons and velocities as well as sea offsets
    
    for (int i=0; i<7; i++) {
      lf_set(target_pos_ext[i], self->scaled_joint_pos[i]);   // Update target positions
      lf_set(target_vel_ext[i], self->scaled_joint_vel[i]);   // Update target velocities
      //printf("ROS_Interface: Sending target_vel_ext[%d] = %d (from scaled_joint_vel = %d)\r\n", 
      //       i, (int)(self->scaled_joint_vel[i] * 1000), (int)(self->scaled_joint_vel[i] * 1000));
      lf_set(sea_lim[i], self->scaled_sea_lim[i]);      // Update sea offset values


      HAL_GPIO_WritePin(GPIOH, GPIO_PIN_1, HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_1));
      if (HAL_GPIO_ReadPin(GPIOC, GPIO_PIN_1)) {
        lf_set(sea_offset[i], 0);      // Update sea offset values
      } else {
        lf_set(sea_offset[i], self->scaled_sea_offset[i]);      // Update sea offset values
      }
    }
  =}

}
