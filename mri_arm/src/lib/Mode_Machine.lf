target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include "stm32_startup.h"
  #include <stdio.h>

  #include <../../../motor_config.h>
  #include <../../../joint_config.h>
  #include <../../../sm_config.h>

  /*
  typedef struct mode_status{
    MODE_ENUM current_mode_index;
    bool is_homing_finished;
    bool enable_homing_command;
    bool enable_motor_command;
    bool force_disable_motor_pins;
    TARGET_SRC motor_controller_internal_external_target_mode;
    MOTOR_MODE[7] motor_controller_target_sel;
  } mode_status;
  */
=}

reactor ModeMachine (refresh_period: time = 5 ms, slow_refresh_period: time = 20 ms, status_refresh_period: time = 1000 ms){
    input set_mode_change: MODE_ENUM 
    input is_homing_finished: bool

    output reset_qdec: bool
    output motor_controller_internal_external_target_mode: TARGET_SRC // maybe rename this enum type, it's vague
    output[7] motor_controller_target_sel: MOTOR_MODE
    //output[7] motor_controller_target_velocity_external: float // really not sure if we want this one here
    //output[7] motor_controller_target_velocity_internal: float // we should use this to force velocities to zero when idling

    output enable_homing_command: bool
    output enable_motor_command: bool
    output force_disable_motor_pins: bool

    // timer for sending updates depending on the current mode
    //timer system_tick(0 ms, refresh_period) // unused!
    timer slow_system_tick(0 ms, slow_refresh_period)
    timer slow_status_tick(0 ms, status_refresh_period)

    state _is_homing_finished: bool = false // consider depreciating these
    state _current_mode: MODE_ENUM = 0 // consider depreciating these // initially set to idle
    //state _current_mode_name: string = "STARTUP" // consider depreciating these

    state staged_mode_status: mode_status = {0, false, false, false, true, 0, {0, 0, 0, 0, 0, 0, 0}}
    state flag_ready_to_update_mode_status: bool = false
    state flag_ready_to_change_modes: bool = false

    preamble {= 
      void set_power_relay(bool on_or_off){return;}; // TODO: impliment this when we get a working relay.
    =}

    method printModeStatus(): void {=
      printf("### MODE MACHINE STATUS ###\r\n");
      printf("# current_mode_index: %d\r\n", self->staged_mode_status.current_mode_index);
      printf("# is_homing_finished: %d\r\n", self->staged_mode_status.is_homing_finished);
      printf("# enable_homing_command: %d\r\n", self->staged_mode_status.enable_homing_command);
      printf("# enable_motor_command: %d\r\n", self->staged_mode_status.enable_motor_command);
      printf("# force_disable_motor_pins: %d\r\n", self->staged_mode_status.force_disable_motor_pins);
      printf("# motor_controller_internal_external_target_mode: %d\r\n", self->staged_mode_status.motor_controller_internal_external_target_mode);
      printf("# motor_controller_target_sel:");
      for (int i = 0; i<6; i++){
        printf("%d, ", self->staged_mode_status.motor_controller_target_sel[i]);
      }
      printf("%d\r\n", self->staged_mode_status.motor_controller_target_sel[6]);
      printf("###########################\r\n\r\n");
      =}
    
    method handleModeSwitch(set_mode_enum: MODE_ENUM): void {=
      if (set_mode_enum == SET_IDLE){
        printf("Starting mode switch to idle...\r\n");
        enableIdleMotorSettings();  
        self->staged_mode_status.current_mode_index = SET_IDLE;
      } 
      else if(set_mode_enum == SET_HOMING){
        printf("Starting mode switch to homing...\r\n");
        setHomingMotorSettings();
        self->staged_mode_status.current_mode_index = SET_HOMING;
      }
      else if(set_mode_enum == SET_RUN_POS){
        printf("Starting mode switch to running with position control...\r\n");
        if (self->_is_homing_finished){
          setRunMotorSettings(true);
          self->staged_mode_status.current_mode_index = SET_RUN_POS;
        }
        else {
          printf("!!! Homing is not finished! Cannot do position control. Reverting to IDLE mode... !!!\r\n");
          handleModeSwitch(SET_IDLE);
          return;
        }
      }
      else if(set_mode_enum == SET_RUN_VEL){
        printf("Starting mode switch to running with velocity control...\r\n");
        setRunMotorSettings(false);
        self->staged_mode_status.current_mode_index = SET_RUN_VEL;
      }
      else {
        printf("handleModeSwitch did not receive a valid set_mode_enum input. Got %d, but expected %d, %d, %d, or %d\r\n", 
          set_mode_enum, SET_IDLE, SET_HOMING, SET_RUN_POS, SET_RUN_VEL);
        self->flag_ready_to_update_mode_status = false;
        self->flag_ready_to_change_modes = false;
        return;
      }
      self->flag_ready_to_update_mode_status = true;
      self->flag_ready_to_change_modes = true;
      return;
    =}
    
    // method for initalizing values when switching into idle mode
    method enableIdleMotorSettings(): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = true;

      // Set source as internal to ignore motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_INT;

      for (int i=0; i<7; i++) {
        // Set each motor mode to velocity control
        self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
        
      }

      // Disable sending motor or homing commands from their reactors
      self->staged_mode_status.enable_motor_command = false;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}

    // method for initalizing values when switching into homing mode.
    method setHomingMotorSettings(): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = false;

      // Set source as internal to ignore motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_INT;

      // Set the mode as velocity control
      for (int i=0; i<7; i++) {
        //lf_set(motor_controller_target_sel[i], MODE_VEL); 
        self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
      }

      // Set homing and motor controllers to active
      self->staged_mode_status.enable_motor_command = true;
      self->staged_mode_status.enable_homing_command = true;
      return;
    =}

    method setRunMotorSettings(use_position_control: bool): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = false;

      // Set source as extneral to follow motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_EXT;

      // Set the mode to either position or velocity control
      for (int i=0; i<7; i++) {
        if (use_position_control){
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_POS;
        }
        else{
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
        }
      }

      // Disable homing commands and enable motor commands
      self->staged_mode_status.enable_motor_command = true;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}
    
    reaction(slow_status_tick) {=
      printModeStatus();
      =}


    //##### 
    //# Modes
    //#####

    initial mode STARTUP {
      reaction(slow_system_tick) -> IDLE {=
        lf_set_mode(IDLE);
        handleModeSwitch(SET_IDLE);
      =}
    }

    mode IDLE {
      
      
      reaction(slow_system_tick) -> force_disable_motor_pins, HOME, RUN{=
        //lf_set(force_disable_motor_pins, true); // keeps motor pins disabled, may be redundant -> maybe interfering!
        //set_power_relay(false); // set power relay to off

        // this has to be done in modal reactors, can't be a single external reactor...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}
      
      reaction updateMode (set_mode_change) {=// -> IDLE  HOME, RUN{=
        handleModeSwitch(set_mode_change->value);
      =}
      
    }
    
    
    mode HOME {
      
      reaction(slow_system_tick) -> IDLE{=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            default:
              lf_set_mode(IDLE);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}
      
      
      reaction updateMode (set_mode_change){=
        handleModeSwitch(set_mode_change->value);
      =}
      
      reaction (is_homing_finished)  -> reset_qdec{=
        if (is_homing_finished->value){
          self->_is_homing_finished = is_homing_finished->value;
          lf_set(reset_qdec, true);
          printf("--- Finished Homing ---\r\n");
          handleModeSwitch(SET_IDLE);
        }
      =}
    
    }

    mode RUN {
      
      reaction(slow_system_tick) -> IDLE, RUN{=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change){=
        handleModeSwitch(set_mode_change->value);
        
      =}
        
    }
    

    //##### 
    //# Input reactions
    //#####

    //##### 
    //# Output reactions
    //#####

    reaction update_mode_status (slow_system_tick) -> enable_homing_command, enable_motor_command, force_disable_motor_pins,
    motor_controller_internal_external_target_mode, motor_controller_target_sel{=
      if (self->flag_ready_to_update_mode_status){
        lf_set(enable_homing_command, self->staged_mode_status.enable_homing_command);
        lf_set(enable_motor_command, self->staged_mode_status.enable_motor_command);
        lf_set(force_disable_motor_pins, self->staged_mode_status.force_disable_motor_pins);
        lf_set(motor_controller_internal_external_target_mode, self->staged_mode_status.motor_controller_internal_external_target_mode);
        for (int i=0; i<7; i++){
          lf_set(motor_controller_target_sel[i], self->staged_mode_status.motor_controller_target_sel[i]);
        }
        self->flag_ready_to_update_mode_status = false;
      }
    =}
}


/*
typedef struct mode_status{
    int current_mode_index;
    bool is_homing_finished;
    bool enable_homing_command;
    bool enable_motor_command;
    bool force_disable_motor_pins;
    TARGET_SRC motor_controller_internal_external_target_mode;
    MOTOR_MODE[7] motor_controller_target_sel;
  } mode_status;
*/

/*
    method handleModeSwitch(set_mode_enum: MODE_ENUM): void {=
      switch (set_mode_enum->value) {
        case 0: // set mode to idle
          
          enableIdleMotorSettings();  
          lf_set_mode(IDLE);
          printf("Mode set to IDLE!");
          //_current_mode_name->value = "IDLE";
          
        case 1: // set mode to home
          printf("Starting mode switch to homing...");
          setHomingMotorSettings();  
          lf_set_mode(HOME);
          printf("Mode set to HOME!");
          //_current_mode_name->value = "HOME";
        
        case 2: // set mode to run, use pos control
          printf("Starting mode switch to running with position control...");
          if (self->_is_homing_finished){
            setRunMotorSettings(true);
            lf_set_mode(RUN);
            printf("Mode set to RUN!");
            //_current_mode_name->value = "RUN_POS";
          }
          else {
            printf("!!! Homing is not finished! Cannot do position control. Reverting to IDLE mode... !!!");
            handleModeSwitch(SET_IDLE);
            return;
          }
          
        case 3: // set mode to run, use vel control
          printf("Starting mode switch to running with velocity control...");
          setRunMotorSettings(false);
          lf_set_mode(RUN);
          //_current_mode_name->value = "RUN_VEL";
          printf("Mode set to RUN!");
      }
      _current_mode->value = set_mode_enum->value;
      return;
    =}
    */

    /*
      reaction(slow_system_tick) -> IDLE, HOME, RUN{=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}
      */