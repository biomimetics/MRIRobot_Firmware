target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include "stm32_startup.h"
  #include <stdio.h>

  #include <../../../motor_config.h>
  #include <../../../joint_config.h>
  #include <../../../sm_config.h>

  /*
  typedef struct mode_status{
    MODE_ENUM current_mode_index;
    bool is_homing_finished;
    bool enable_homing_command;
    bool enable_motor_command;
    bool force_disable_motor_pins;
    TARGET_SRC motor_controller_internal_external_target_mode;
    MOTOR_MODE[7] motor_controller_target_sel;
  } mode_status;
  */
=}

reactor ModeMachine (refresh_period: time = 5 ms, slow_refresh_period: time = 20 ms){
    input set_mode_change: MODE_ENUM 
    input is_homing_finished: bool

    output reset_qdec: bool
    output motor_controller_internal_external_target_mode: TARGET_SRC // maybe rename this enum type, it's vague
    output[7] motor_controller_target_sel: MOTOR_MODE
    //output[7] motor_controller_target_velocity_external: float // really not sure if we want this one here
    //output[7] motor_controller_target_velocity_internal: float // we should use this to force velocities to zero when idling

    output enable_homing_command: bool
    output enable_motor_command: bool
    output force_disable_motor_pins: bool

    // timer for sending updates depending on the current mode
    timer system_tick(0 ms, refresh_period)
    timer slow_system_tick(0 ms, slow_refresh_period)

    state _is_homing_finished: bool = false // consider depreciating these
    state _current_mode: MODE_ENUM = 0 // consider depreciating these // initially set to idle
    state _current_mode_name: string = "STARTUP" // consider depreciating these

    state staged_mode_status: mode_status = {0, false, false, false, true, 0, {0, 0, 0, 0, 0, 0, 0}}
    state flag_ready_to_update_mode_status: bool = false
    state flag_ready_to_change_modes: bool = false

    preamble {= 
      void set_power_relay(bool on_or_off){return;}; // TODO: impliment this when we get a working relay.
    =}

    
    method handleModeSwitch(set_mode_enum: MODE_ENUM): void {=
      switch (set_mode_enum->value) {
        case SET_IDLE: // set mode to idle
          printf("Starting mode switch to idle...");
          enableIdleMotorSettings();  
          self->staged_mode_status.current_mode_index = SET_IDLE;
          
        case SET_HOMING: // set mode to home
          printf("Starting mode switch to homing...");
          setHomingMotorSettings();
          self->staged_mode_status.current_mode_index = SET_HOMING;
        
        case SET_RUN_POS: // set mode to run, use pos control
          printf("Starting mode switch to running with position control...");
          if (self->_is_homing_finished){
            setRunMotorSettings(true);
            self->staged_mode_status.current_mode_index = SET_RUN_POS;
          }
          else {
            printf("!!! Homing is not finished! Cannot do position control. Reverting to IDLE mode... !!!");
            handleModeSwitch(SET_IDLE);
            return;
          }
          
        case SET_RUN_VEL: // set mode to run, use vel control
          printf("Starting mode switch to running with velocity control...");
          setRunMotorSettings(false);
          self->staged_mode_status.current_mode_index = SET_RUN_VEL;
      }
      self->flag_ready_to_update_mode_status = true;
      self->flag_ready_to_change_modes = true;
      return;
    =}
    
    // method for initalizing values when switching into idle mode
    method enableIdleMotorSettings(force_disable_motor_pins): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = true;

      // Set source as internal to ignore motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_INT;

      for (int i=0; i<7; i++) {
        // Set each motor mode to velocity control
        self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL
        
      }

      // Disable sending motor or homing commands from their reactors
      self->staged_mode_status.enable_motor_command = false;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}

    // method for initalizing values when switching into homing mode.
    method setHomingMotorSettings(): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = false;

      // Set source as internal to ignore motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_INT;

      // Set the mode as velocity control
      for (int i=0; i<7; i++) {
        //lf_set(motor_controller_target_sel[i], MODE_VEL); 
        self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL
      }

      // Set homing and motor controllers to active
      self->staged_mode_status.enable_motor_command = true;
      self->staged_mode_status.enable_homing_command = true;
      return;
    =}

    method setRunMotorSettings(use_position_control: bool): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = false;

      // Set source as extneral to follow motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_EXT;

      // Set the mode to either position or velocity control
      for (int i=0; i<7; i++) {
        if (use_position_control){
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_POS
        }
        else{
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL
        }
      }

      // Disable homing commands and enable motor commands
      lf_set(enable_homing_command, false);
      lf_set(enable_motor_command, true);
      return;
    =}
    
    /*##### 
    # Modes
    #####*/

    initial mode STARTUP {
      reaction(system_tick) -> IDLE {=
      lf_set_mode(IDLE);
    =}
      
    }

    mode IDLE {
      reaction(slow_system_tick) -> force_disable_motor_pins{=
        lf_set(force_disable_motor_pins, true); // keeps motor pins disabled, may be redundant
        set_power_relay(false); // set power relay to off

        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change) -> IDLE, HOME, RUN{=
        handleModeSwitch(set_mode_change->value);
      =}
      
    }
    

    mode HOME {
      reaction(slow_system_tick){=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change) -> IDLE, HOME, RUN{=
        handleModeSwitch(set_mode_change->value);
      =}
      
      reaction(is_homing_finished) -> reset_qdec{=
        if (is_homing_finished->value){
          self->_is_homing_finished = is_homing_finished->value;
          lf_set(reset_qdec, true);
          printf("--- Finished Homing ---\r\n");
          handleModeSwitch(SET_IDLE);
        }
      =}
      
      
    }

    mode RUN {
      reaction(slow_system_tick){=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change) -> IDLE, HOME, RUN{=
        handleModeSwitch(set_mode_change);
        
      =}
    }

    /*##### 
    # Input reactions
    #####*/

    /*##### 
    # Output reactions
    #####*/

    reaction update_mode_status (slow_system_tick) -> enable_homing_command, enable_motor_command, force_disable_motor_pins,
    motor_controller_internal_external_target_mode, motor_controller_target_sel{=
      if (self->flag_ready_to_update_mode_status){
        lf_set(enable_homing_command, self->staged_mode_status.enable_homing_command);
        lf_set(enable_motor_command, self->staged_mode_status.enable_motor_command);
        lf_set(force_disable_motor_pins, self->staged_mode_status.force_disable_motor_pins);
        lf_set(motor_controller_internal_external_target_mode, self->staged_mode_status.motor_controller_internal_external_target_mode);
        for (int i=0; i<7, i++){
          lf_set(motor_controller_target_sel[i], self->staged_mode_status.motor_controller_target_sel[i]);
        }
        self->flag_ready_to_update_mode_status = false;
      }
    =}
}

/*
typedef struct mode_status{
    int current_mode_index;
    bool is_homing_finished;
    bool enable_homing_command;
    bool enable_motor_command;
    bool force_disable_motor_pins;
    TARGET_SRC motor_controller_internal_external_target_mode;
    MOTOR_MODE[7] motor_controller_target_sel;
  } mode_status;
*/

/*
    method handleModeSwitch(set_mode_enum: MODE_ENUM): void {=
      switch (set_mode_enum->value) {
        case 0: // set mode to idle
          
          enableIdleMotorSettings();  
          lf_set_mode(IDLE);
          printf("Mode set to IDLE!");
          //_current_mode_name->value = "IDLE";
          
        case 1: // set mode to home
          printf("Starting mode switch to homing...");
          setHomingMotorSettings();  
          lf_set_mode(HOME);
          printf("Mode set to HOME!");
          //_current_mode_name->value = "HOME";
        
        case 2: // set mode to run, use pos control
          printf("Starting mode switch to running with position control...");
          if (self->_is_homing_finished){
            setRunMotorSettings(true);
            lf_set_mode(RUN);
            printf("Mode set to RUN!");
            //_current_mode_name->value = "RUN_POS";
          }
          else {
            printf("!!! Homing is not finished! Cannot do position control. Reverting to IDLE mode... !!!");
            handleModeSwitch(SET_IDLE);
            return;
          }
          
        case 3: // set mode to run, use vel control
          printf("Starting mode switch to running with velocity control...");
          setRunMotorSettings(false);
          lf_set_mode(RUN);
          //_current_mode_name->value = "RUN_VEL";
          printf("Mode set to RUN!");
      }
      _current_mode->value = set_mode_enum->value;
      return;
    =}
    */
