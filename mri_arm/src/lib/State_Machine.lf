target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
  //cmake-include: [
  //    "../include_c/stm_comms_cmake.cmake"]
  //files: ["/include_c/stm_comms.h", "/src_c/stm_comms.c"]
}

preamble {=
  #include "stm32f4xx_hal.h"
  //#include "stm32_startup.h"
  #include "main.h"
  #include <stdio.h>

  #include "motor_config.h"
  #include "sm_config.h"
  #include "common.h"
  #include "stm_comms.h"
  //#include "stm_comms.c"

  #define PRINT_MODE 0
  #define PRINT_MODE_STATUS 0

  #define MESSAGE_INDEX_MOD 256
=}

reactor StateMachine(slow_refresh_period: time = 20 ms, status_refresh_period: time = 1000 ms, update_state_message_period: time = 10 ms){
    // inputs from serial
    input command_message: CommandMessage

    // outputs to serial
    output state_message: StateMessage

    // inputs from encoders
    input[7] motor_encoder_positions: float
    input[7] motor_encoder_velocities: float
    input[7] sea_encoder_positions: float

    // outputs to encoders
    output enable_qdec: bool
    output reset_qdec: bool

    // inputs from usm
    input[7] usm_duty_cycles: float

    // outputs to usm
    output[7] commanded_motor_velocities: float
    output enable_motor_command: bool // triggered when we're in the right state
    output[7] force_disable_motor_pins: bool // used to disable specific motors if they've hit convergence or for safety reasons.

    // internal copies of inputs    
    state motor_encoder_positions_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    state motor_encoder_velocities_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    state sea_encoder_positions_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    state usm_duty_cycles_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}

    // internal copies of staged outputs
    state state_msg_: StateMessage
    state cmd_msg_: CommandMessage
    state staged_commanded_motor_velocities_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    state last_staged_commanded_motor_velocities_: float[7] = {0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0}
    state force_disable_motor_pins_: bool[7] = {false, false, false, false, false, false, false}
    state enable_motor_command_: bool = false

    // helper states
    state send_message_index: int = 0
    state current_behavior_mode_: int = 0 // 0 for idle, 1 for run, 2 for error
    state last_received_message_index: int = 0
    state missed_message_counter: int = 0

    timer update_state_message_tick(0 ms, update_state_message_period)
    timer slow_system_tick(0 ms, slow_refresh_period)
    timer slow_status_tick(0 ms, status_refresh_period)

    preamble {= 
      void set_power_relay(bool on_or_off){return;}; // TODO: impliment this when we get a working relay.HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    0);
    =}
    
    method commanded_velocity_santiy_checks(index: int) {=
      
    =}

    reaction(startup) -> enable_qdec, reset_qdec{=
      lf_set(enable_qdec, true); // turn the encoders on right at the start
      lf_set(reset_qdec, true);

      printf("State Machine has finished startup!\n");
      =}
    
    reaction(slow_status_tick) {=
      //if (PRINT_MODE_STATUS){
      //printf("In state: %d\n", self->current_behavior_mode_);
      //}
      //toggleStatusLED();
    =}


    //##### 
    //# Input reactions
    //#####

    
    reaction(command_message) -> enable_motor_command, force_disable_motor_pins, commanded_motor_velocities {=
      self->cmd_msg_ = command_message->value;

      //printf("State_Machine received command_message of:\n");
      //print_command_message_int(&self->cmd_msg_);

      // get the behavior mode and see if we need to handle a behavior change

      //printf("Got state: %d\n", self->cmd_msg_.behavior_mode);
      //printf("Is it different from current state?: %d\n", self->current_behavior_mode_ != self->cmd_msg_.behavior_mode);
      if (self->current_behavior_mode_ != self->cmd_msg_.behavior_mode){
        //if (self->cmd_msg_.behavior_mode == SET_IDLE){
        if (self->cmd_msg_.behavior_mode == 0){ // SET_IDLE
          self->enable_motor_command_ = false;
          self->current_behavior_mode_ = self->cmd_msg_.behavior_mode;
          printf("Switching to Idle state...\n");
        }
        else if (self->cmd_msg_.behavior_mode == 1){ // SET_RUN
          self->enable_motor_command_ = true;
          self->current_behavior_mode_ = self->cmd_msg_.behavior_mode;
          printf("Switching to Run state...\n");
        }
        else if (self->cmd_msg_.behavior_mode == 2){ //SET_ERROR // externally triggered error state. means something went wrong on ROS side and we need to shut down for safety reasons.
          self->enable_motor_command_ = false;
          self->current_behavior_mode_ = self->cmd_msg_.behavior_mode;
          printf("Switching to Error state...\n");
        }
        else{
          // bad value!
          self->enable_motor_command_ = false;
          self->current_behavior_mode_ = SET_IDLE;
        }
      }

      // ignore the positions for now, use for bounds checking

      // velocities are most important!
      for (int i = 0; i<DOF_NUMBER; i++){
        self->staged_commanded_motor_velocities_[i] = self->cmd_msg_.velocities[i];
      }

      // do sanity check on staged velocities here! move these to method after we've made sure they work correctly
      for (int i = 0; i<DOF_NUMBER; i++){
        // clamp the values to be in a small region around the last velocity to prevent high accelerations at startup
        if (self->staged_commanded_motor_velocities_[i] <  (self->last_staged_commanded_motor_velocities_[i] - MOTOR_VELOCITY_MAX_CHANGE)){
          self->staged_commanded_motor_velocities_[i] = self->last_staged_commanded_motor_velocities_[i] - MOTOR_VELOCITY_MAX_CHANGE;
        }
        else if ((self->last_staged_commanded_motor_velocities_[i] + MOTOR_VELOCITY_MAX_CHANGE) < self->staged_commanded_motor_velocities_[i]){
          self->staged_commanded_motor_velocities_[i] = self->last_staged_commanded_motor_velocities_[i] + MOTOR_VELOCITY_MAX_CHANGE;
        }

        // apply the deadband here before we try any filtering. if deadband is applied, set that channel's motor enable pin to be off.
        if ((self->staged_commanded_motor_velocities_[i] < MOTOR_VELOCITY_DEADBAND_LIMIT) && ((-MOTOR_VELOCITY_DEADBAND_LIMIT < self->staged_commanded_motor_velocities_[i]))){
          self->staged_commanded_motor_velocities_[i] = 0.0;
          self->force_disable_motor_pins_[i] = true;
        }
        else{
          self->force_disable_motor_pins_[i] = false;
        }

        // apply a light filter to keep things smooth even with the clamping and deadbands
        self->staged_commanded_motor_velocities_[i] = (MOTOR_EXP_FILTER_ALPHA) * self->staged_commanded_motor_velocities_[i] + (1.0 - MOTOR_EXP_FILTER_ALPHA) * self->last_staged_commanded_motor_velocities_[i];
        
        // save the clamped, smooth commands for the next loop
        self->last_staged_commanded_motor_velocities_[i] = self->staged_commanded_motor_velocities_[i];

      }
      
      // ignore sea position terms

      // check to see if we've missed a message somewhere. we should always expect this number to increase by 1 every loop.
      if (self->last_received_message_index != (self->cmd_msg_.message_index - 1)){
        self->missed_message_counter++;
      }
      self->last_received_message_index = self->cmd_msg_.message_index % MESSAGE_INDEX_MOD;

      // set all outputs at the end of reaction
      
      for (int i = 0; i<DOF_NUMBER; i++){
        lf_set(commanded_motor_velocities[i], self->staged_commanded_motor_velocities_[i]);
        lf_set(force_disable_motor_pins[i], self->force_disable_motor_pins_[i]);
      }

      lf_set(enable_motor_command, self->enable_motor_command_);
    =}
    

    // TODO: Add sanity checks to the encoder readings to ensure that there isn't a connection error or something.
    reaction(motor_encoder_positions) {=
      for (int i = 0; i<DOF_NUMBER; i++){
        self->motor_encoder_positions_[i] = motor_encoder_positions[i]->value;
      }
    =}

    reaction(motor_encoder_velocities) {=
      //printf("State Machine: Got velocities of:\n");
      for (int i = 0; i<DOF_NUMBER; i++){
        self->motor_encoder_velocities_[i] = motor_encoder_velocities[i]->value;
        //printf("%d:", (int) (motor_encoder_velocities[i]->value*1000));
        //printf("%d, ", (int) (self->motor_encoder_velocities_[i]*1000));
      }
      //printf("\n");
    =}

    reaction(sea_encoder_positions) {=
      for (int i = 0; i<DOF_NUMBER; i++){ 
        self->sea_encoder_positions_[i] = sea_encoder_positions[i]->value;
      }
    =}

    reaction(usm_duty_cycles) {=
      for (int i = 0; i<DOF_NUMBER; i++){ 
        self->usm_duty_cycles_[i] = usm_duty_cycles[i]->value;
      }
    =}

    //##### 
    //# Output reactions
    //#####

    
    reaction(update_state_message_tick) -> state_message {=
      float extra_array_[EXTRA_LENGTH];

      for (int i = 0; i<DOF_NUMBER; i++){
        extra_array_[i] = self->staged_commanded_motor_velocities_[i]; //target_joint_pos_[i];
        extra_array_[i+7] = 0.0; //usm_motor_speeds_[i];
        extra_array_[i+14] = self->usm_duty_cycles_[i];
      }
      
      int time_stamp = HAL_GetTick();
      
      construct_state_message(&self->state_msg_, self->current_behavior_mode_,
                              self->motor_encoder_positions_, self->motor_encoder_velocities_,
                              self->sea_encoder_positions_, extra_array_,
                              time_stamp, self->send_message_index++);

      lf_set(state_message, self->state_msg_);
    =}
    
}

/*
reactor StateMachine(slow_refresh_period: time = 20 ms, status_refresh_period: time = 1000 ms){
    // inputs from serial
    input command_message: CommandMessage

    // inputs from encoders
    input[7] motor_encoder_position: float
    input[7] sea_encoder_position: float
    input[7] motor_encoder_velocity: float

    // inputs from usm
    input[7] usm_duty_cycle: float

    // outputs to serial
    output state_message: StateMessage

    // outputs to encoders
    output enable_qdec: bool
    output reset_qdec: bool
    
    // outputs to usm
    output enable_motor_command: bool // triggered when we're in the right state
    output force_disable_motor_pins: bool // emergency disable of motor pins
    

    // timer for sending updates depending on the current mode
    state current_mode_: MODE_ENUM = 0 // consider depreciating these // initially set to idle

    state staged_mode_status: mode_status = {0, false, false, false, true, 0, {0, 0, 0, 0, 0, 0, 0}}
    state flag_ready_to_update_mode_status: bool = false
    state flag_ready_to_change_modes: bool = false

    state status_led_on: bool = false
    state status_led_counter: int = 0s
    state status_led_counter_limit: int = 50 // number of slow ticks to wait

    timer slow_system_tick(0 ms, slow_refresh_period)
    timer slow_status_tick(0 ms, status_refresh_period)

    preamble {= 
      void set_power_relay(bool on_or_off){return;}; // TODO: impliment this when we get a working relay.HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    0);

    =}


    method printModeStatus(): void {=
      printf("### MODE MACHINE STATUS ###\r\n");
      printf("# current_mode_index: %d\r\n", self->staged_mode_status.current_mode_index);
      printf("# is_homing_finished: %d\r\n", self->staged_mode_status.is_homing_finished);
      printf("# enable_homing_command: %d\r\n", self->staged_mode_status.enable_homing_command);
      printf("# enable_motor_command: %d\r\n", self->staged_mode_status.enable_motor_command);
      printf("# force_disable_motor_pins: %d\r\n", self->staged_mode_status.force_disable_motor_pins);
      printf("# motor_controller_internal_external_target_mode: %d\r\n", self->staged_mode_status.motor_controller_internal_external_target_mode);
      printf("# motor_controller_target_sel:");
      for (int i = 0; i<6; i++){
        printf("%d, ", self->staged_mode_status.motor_controller_target_sel[i]);
      }
      printf("%d\r\n", self->staged_mode_status.motor_controller_target_sel[6]);
      printf("###########################\r\n\r\n");
      =}
    
    method handleModeSwitch(set_mode_enum: MODE_ENUM): void {=
      if (set_mode_enum == SET_IDLE){
        printf("Starting mode switch to idle...\r\n");
        enableIdleMotorSettings();  
        self->staged_mode_status.current_mode_index = SET_IDLE;
      } 
      else if(set_mode_enum == SET_RUN_VEL){
        printf("Starting mode switch to running with velocity control...\r\n");
        setRunMotorSettings(false);
        self->staged_mode_status.current_mode_index = SET_RUN_VEL;
      }
      else {
        printf("handleModeSwitch did not receive a valid set_mode_enum input. Got %d, but expected %d, %d, %d, or %d\r\n", 
          set_mode_enum, SET_IDLE, SET_HOMING, SET_RUN_POS, SET_RUN_VEL);
        self->flag_ready_to_update_mode_status = false;
        self->flag_ready_to_change_modes = false;
        return;
      }
      self->flag_ready_to_update_mode_status = true;
      self->flag_ready_to_change_modes = true;
      return;
    =}
    
    // method for initalizing values when switching into idle mode
    method enableIdleMotorSettings(): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = true;

      // Set source as internal to ignore motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_INT;

      for (int i=0; i<7; i++) {
        // Set each motor mode to velocity control
        self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
        
      }

      // Disable sending motor or homing commands from their reactors
      self->staged_mode_status.enable_motor_command = false;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}


    method setRunMotorSettings(use_position_control: bool): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = false;

      // Set source as extneral to follow motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_EXT;

      // Set the mode to either position or velocity control
      for (int i=0; i<7; i++) {
        if (use_position_control){
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_POS;
        }
        else{
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
        }
      }

      // Disable homing commands and enable motor commands
      self->staged_mode_status.enable_motor_command = true;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}
    
    reaction(slow_status_tick) {=
      if (PRINT_MODE_STATUS){
        printModeStatus();
      }
      //toggleStatusLED();
      =}


    //##### 
    //# Modes
    //#####

    initial mode STARTUP {
      reaction(slow_system_tick) -> IDLE {=
        lf_set_mode(IDLE);
        handleModeSwitch(SET_IDLE);
      =}
    }

    mode IDLE {
      
      
      reaction(slow_system_tick) -> force_disable_motor_pins, HOME, RUN{=
        //lf_set(force_disable_motor_pins, true); // keeps motor pins disabled, may be redundant -> maybe interfering!
        //set_power_relay(false); // set power relay to off

        // this has to be done in modal reactors, can't be a single external reactor...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}
      
      reaction updateMode (set_mode_change) {=// -> IDLE  HOME, RUN{=
        handleModeSwitch(set_mode_change->value);
      =}
      
    }
    

    mode RUN {
      
      reaction(slow_system_tick) -> IDLE, RUN{=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change){=
        handleModeSwitch(set_mode_change->value);
        
      =}
        
    }

    mode ERROR {
      
      reaction(slow_system_tick) -> IDLE {=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change){=
        handleModeSwitch(set_mode_change->value);
        
      =}
        
    }
    

    //##### 
    //# Input reactions
    //#####

    //##### 
    //# Output reactions
    //#####

    reaction update_mode_status (slow_system_tick) -> enable_homing_command, enable_motor_command, force_disable_motor_pins,
    current_mode_status{=
      if (self->flag_ready_to_update_mode_status){
        lf_set(enable_homing_command, self->staged_mode_status.enable_homing_command);
        lf_set(enable_motor_command, self->staged_mode_status.enable_motor_command);
        lf_set(force_disable_motor_pins, self->staged_mode_status.force_disable_motor_pins);
        
        //lf_set(motor_controller_internal_external_target_mode, self->staged_mode_status.motor_controller_internal_external_target_mode);
        //for (int i=0; i<7; i++){
        //  lf_set(motor_controller_target_sel[i], self->staged_mode_status.motor_controller_target_sel[i]);
        //}

        self->flag_ready_to_update_mode_status = false;
      }
      lf_set(current_mode_status, self->staged_mode_status);
    =}
}
*/