target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  //#include "stm32_startup.h"
  #include "main.h"
  #include <stdio.h>

  #include <../../../include/motor_config.h>
  #include <../../../include/sm_config.h>
  #include <../../../include/common_structs.h>

  #define PRINT_MODE 0
  #define PRINT_MODE_STATUS 0
=}

reactor StateMachine(slow_refresh_period: time = 20 ms, status_refresh_period: time = 1000 ms, update_state_message_period: time = 10 ms){
    // inputs from serial
    input command_message: CommandMessage

    // inputs from encoders
    input[7] motor_encoder_positions: float
    input[7] motor_encoder_velocities: float
    input[7] sea_encoder_positions: float

    // inputs from usm
    input[7] usm_duty_cycles: float

    // outputs to serial
    output state_message: StateMessage

    // outputs to encoders
    output enable_qdec: bool
    output reset_qdec: bool
    
    // outputs to usm
    output[7] commanded_motor_velocities: float
    output enable_motor_command: bool // triggered when we're in the right state
    output force_disable_motor_pins: bool // emergency disable of motor pins

    // internal copies of inputs
    
    state motor_encoder_positions_: float[7]
    state motor_encoder_velocities_: float[7]
    state sea_encoder_positions_: float[7]
    state usm_duty_cycles_: float[7]

    // internal copies of staged outputs
    state state_msg_: StateMessage
    state cmd_msg_: CommandMessage
    state staged_commanded_motor_velocities_: float[7]

    // helper states
    state send_message_index: int = 0
    state current_behavior_mode_: int = 0 // 0 for idle, 1 for run, 2 for error
    state last_received_message_index: int = 0
    state missed_message_counter: int = 0

    timer update_state_message_tick(0 ms, update_state_message_period)
    timer slow_system_tick(0 ms, slow_refresh_period)
    timer slow_status_tick(0 ms, status_refresh_period)

    preamble {= 
      void set_power_relay(bool on_or_off){return;}; // TODO: impliment this when we get a working relay.HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    0);

    =}
    
    reaction(startup) -> enable_qdec, reset_qdec{=
      lf_set(enable_qdec, true); // turn the encoders on right at the start
      lf_set(reset_qdec, true)
      =}
    
    reaction(slow_status_tick) {=
      if (PRINT_MODE_STATUS){
        //printModeStatus();
      }
      //toggleStatusLED();
    =}


    //##### 
    //# Input reactions
    //#####

    reaction(command_message) -> enable_motor_command, commanded_motor_velocities {=
      self->cmd_msg_ = command_message->value;
      // get the behavior mode and see if we need to handle a behavior change
      if (self->current_behavior_mode != self->cmd_msg_.behavior_mode){
        if (self->cmd_msg_.behavior_mode == SET_IDLE){
          lf_set(enable_motor_command, false);
        }
        else if (self->cmd_msg_.behavior_mode == SET_RUN){
          lf_set(enable_motor_command, true);
        }
        else if (self->cmd_msg_.behavior_mode == SET_ERROR){ // externally triggered error state. means something went wrong on ROS side and we need to shut down for safety reasons.
          lf_set(enable_motor_command, false);
        }
        else{
          // bad value!
          lf_set(enable_motor_command, false);
        }
      }

      // ignore the positions for now... could be used for bounds checking?

      // velocities are most important!
      for (int i = 0; i<DOF_NUMBER; i++){
        self->staged_commanded_motor_velocities_[i] = self->cmd_msg_.velocities[i];
      }

      // do sanity check on staged velocities here!

      // set staged velocities after inputs are clamped
      for (int i = 0; i<DOF_NUMBER; i++){
        lf_set(commanded_motor_velocities[i]->value, self->staged_commanded_motor_velocities_[i]);
      }

      // ignore sea position terms

      // check to see if we've missed a message somewhere. we should always expect this number to increase by 1 every loop.
      if (self->last_received_message_index != (self->cmd_msg_.message_index - 1)){
        self->missed_message_counter++;
      }
      self->last_received_message_index = self->cmd_msg_.message_index;

    =}

    // TODO: Add sanity checks to the encoder readings to ensure that there isn't a connection error or something.
    reaction(motor_encoder_positions) {=
      for (int i = 0; i<DOF_NUMBER; i++){
        self->motor_encoder_positions_[i] = motor_encoder_positions[i]->value;
      }
    =}

    reaction(motor_encoder_velocities) {=
      for (int i = 0; i<DOF_NUMBER; i++){
        self->motor_encoder_velocities_[i] = motor_encoder_velocities[i]->value;
      }
    =}

    reaction(sea_encoder_positions) {=
      for (int i = 0; i<DOF_NUMBER; i++){ 
        self->sea_encoder_positions_[i] = sea_encoder_positions[i]->value;
      }
    =}

    reaction(usm_duty_cycles) {=
      for (int i = 0; i<DOF_NUMBER; i++){ 
        self->usm_duty_cycles_[i] = usm_duty_cycles[i]->value;
      }
    =}

    //##### 
    //# Output reactions
    //#####
    reaction(update_state_message_tick) -> state_message {=

      // depreciate the extra_array_ asap.
      float[EXTRA_LENGTH] extra_array_;
      for (int i = 0; i<DOF_NUMBER; i++){
        extra_array_[i] = 0.0; //target_joint_pos_[i];
        extra_array_[i+7] = 0.0; //usm_motor_speeds_[i];
        extra_array_[i+14] = usm_duty_cycle_copy_[i];
      }
      
      int time_stamp = HAL_GetTick();
      construct_state_message(&self->state_msg_, current_behavior_mode_,
                              self->motor_encoder_positions_, self->motor_encoder_velocities_,
                              self->sea_encoder_positions_, extra_array_,
                              time_stamp, self->send_message_index++);
      self->send_message_index = self->send_message_index % 256;

      lf_set(state_message, self->state_msg_);
    =}
    
}

/*
reactor StateMachine(slow_refresh_period: time = 20 ms, status_refresh_period: time = 1000 ms){
    // inputs from serial
    input command_message: CommandMessage

    // inputs from encoders
    input[7] motor_encoder_position: float
    input[7] sea_encoder_position: float
    input[7] motor_encoder_velocity: float

    // inputs from usm
    input[7] usm_duty_cycle: float

    // outputs to serial
    output state_message: StateMessage

    // outputs to encoders
    output enable_qdec: bool
    output reset_qdec: bool
    
    // outputs to usm
    output enable_motor_command: bool // triggered when we're in the right state
    output force_disable_motor_pins: bool // emergency disable of motor pins
    

    // timer for sending updates depending on the current mode
    state current_mode_: MODE_ENUM = 0 // consider depreciating these // initially set to idle

    state staged_mode_status: mode_status = {0, false, false, false, true, 0, {0, 0, 0, 0, 0, 0, 0}}
    state flag_ready_to_update_mode_status: bool = false
    state flag_ready_to_change_modes: bool = false

    state status_led_on: bool = false
    state status_led_counter: int = 0s
    state status_led_counter_limit: int = 50 // number of slow ticks to wait

    timer slow_system_tick(0 ms, slow_refresh_period)
    timer slow_status_tick(0 ms, status_refresh_period)

    preamble {= 
      void set_power_relay(bool on_or_off){return;}; // TODO: impliment this when we get a working relay.HAL_GPIO_WritePin(GPIOB, GPIO_PIN_9,    0);

    =}


    method printModeStatus(): void {=
      printf("### MODE MACHINE STATUS ###\r\n");
      printf("# current_mode_index: %d\r\n", self->staged_mode_status.current_mode_index);
      printf("# is_homing_finished: %d\r\n", self->staged_mode_status.is_homing_finished);
      printf("# enable_homing_command: %d\r\n", self->staged_mode_status.enable_homing_command);
      printf("# enable_motor_command: %d\r\n", self->staged_mode_status.enable_motor_command);
      printf("# force_disable_motor_pins: %d\r\n", self->staged_mode_status.force_disable_motor_pins);
      printf("# motor_controller_internal_external_target_mode: %d\r\n", self->staged_mode_status.motor_controller_internal_external_target_mode);
      printf("# motor_controller_target_sel:");
      for (int i = 0; i<6; i++){
        printf("%d, ", self->staged_mode_status.motor_controller_target_sel[i]);
      }
      printf("%d\r\n", self->staged_mode_status.motor_controller_target_sel[6]);
      printf("###########################\r\n\r\n");
      =}
    
    method handleModeSwitch(set_mode_enum: MODE_ENUM): void {=
      if (set_mode_enum == SET_IDLE){
        printf("Starting mode switch to idle...\r\n");
        enableIdleMotorSettings();  
        self->staged_mode_status.current_mode_index = SET_IDLE;
      } 
      else if(set_mode_enum == SET_RUN_VEL){
        printf("Starting mode switch to running with velocity control...\r\n");
        setRunMotorSettings(false);
        self->staged_mode_status.current_mode_index = SET_RUN_VEL;
      }
      else {
        printf("handleModeSwitch did not receive a valid set_mode_enum input. Got %d, but expected %d, %d, %d, or %d\r\n", 
          set_mode_enum, SET_IDLE, SET_HOMING, SET_RUN_POS, SET_RUN_VEL);
        self->flag_ready_to_update_mode_status = false;
        self->flag_ready_to_change_modes = false;
        return;
      }
      self->flag_ready_to_update_mode_status = true;
      self->flag_ready_to_change_modes = true;
      return;
    =}
    
    // method for initalizing values when switching into idle mode
    method enableIdleMotorSettings(): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = true;

      // Set source as internal to ignore motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_INT;

      for (int i=0; i<7; i++) {
        // Set each motor mode to velocity control
        self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
        
      }

      // Disable sending motor or homing commands from their reactors
      self->staged_mode_status.enable_motor_command = false;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}


    method setRunMotorSettings(use_position_control: bool): void {=
      // allow motor pins to be enabled by USM.lf
      self->staged_mode_status.force_disable_motor_pins = false;

      // Set source as extneral to follow motor commands from ROS
      self->staged_mode_status.motor_controller_internal_external_target_mode = MODE_EXT;

      // Set the mode to either position or velocity control
      for (int i=0; i<7; i++) {
        if (use_position_control){
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_POS;
        }
        else{
          self->staged_mode_status.motor_controller_target_sel[i] = MODE_VEL;
        }
      }

      // Disable homing commands and enable motor commands
      self->staged_mode_status.enable_motor_command = true;
      self->staged_mode_status.enable_homing_command = false;
      return;
    =}
    
    reaction(slow_status_tick) {=
      if (PRINT_MODE_STATUS){
        printModeStatus();
      }
      //toggleStatusLED();
      =}


    //##### 
    //# Modes
    //#####

    initial mode STARTUP {
      reaction(slow_system_tick) -> IDLE {=
        lf_set_mode(IDLE);
        handleModeSwitch(SET_IDLE);
      =}
    }

    mode IDLE {
      
      
      reaction(slow_system_tick) -> force_disable_motor_pins, HOME, RUN{=
        //lf_set(force_disable_motor_pins, true); // keeps motor pins disabled, may be redundant -> maybe interfering!
        //set_power_relay(false); // set power relay to off

        // this has to be done in modal reactors, can't be a single external reactor...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_HOMING: // set mode to home
              lf_set_mode(HOME);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}
      
      reaction updateMode (set_mode_change) {=// -> IDLE  HOME, RUN{=
        handleModeSwitch(set_mode_change->value);
      =}
      
    }
    

    mode RUN {
      
      reaction(slow_system_tick) -> IDLE, RUN{=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
            case SET_RUN_POS: // set mode to run, use pos control
              lf_set_mode(RUN);
            case SET_RUN_VEL: // set mode to run, use vel control
              lf_set_mode(RUN);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change){=
        handleModeSwitch(set_mode_change->value);
        
      =}
        
    }

    mode ERROR {
      
      reaction(slow_system_tick) -> IDLE {=
        // this has to be done in a modal reactor, can't be external...
        if (self->flag_ready_to_change_modes){
          switch (self->staged_mode_status.current_mode_index) {
            case SET_IDLE: // set mode to idle
              lf_set_mode(IDLE);
          }
          self->flag_ready_to_change_modes = false;
        }
      =}

      reaction updateMode (set_mode_change){=
        handleModeSwitch(set_mode_change->value);
        
      =}
        
    }
    

    //##### 
    //# Input reactions
    //#####

    //##### 
    //# Output reactions
    //#####

    reaction update_mode_status (slow_system_tick) -> enable_homing_command, enable_motor_command, force_disable_motor_pins,
    current_mode_status{=
      if (self->flag_ready_to_update_mode_status){
        lf_set(enable_homing_command, self->staged_mode_status.enable_homing_command);
        lf_set(enable_motor_command, self->staged_mode_status.enable_motor_command);
        lf_set(force_disable_motor_pins, self->staged_mode_status.force_disable_motor_pins);
        
        //lf_set(motor_controller_internal_external_target_mode, self->staged_mode_status.motor_controller_internal_external_target_mode);
        //for (int i=0; i<7; i++){
        //  lf_set(motor_controller_target_sel[i], self->staged_mode_status.motor_controller_target_sel[i]);
        //}

        self->flag_ready_to_update_mode_status = false;
      }
      lf_set(current_mode_status, self->staged_mode_status);
    =}
}
*/