target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include <stdio.h>

  #define PRINT_PID_GENERIC 1

  #define NSEC_TO_SEC 0.000000001
  #define MSEC_TO_SEC 0.001
=}

reactor PIDControllerGeneric(rate:time = 5ms, Kp:float=0.0, Kd:float=0.0, Ki:float=0.0, CONTROL_LIMIT:float=1.0, INTEGRAL_CLAMPING_MAX:float=0.0) {
  input current_state: float
  input target_state: float
  output control_signal: float

  // internal copies of IO
  state current_state_: float = 0.0
  state target_state_: float = 0.0
  state control_signal_: float = 0.0

  // to help with state variables
  state last_error: float = 0.0  
  state prev_time: time = 0

  // error and control signal components
  state error: float = 0.0
  state signal_p: float = 0.0
  state signal_d: float = 0.0
  state signal_i: float = 0.0

  timer update_tick(0, rate)

  // gains for control signal components
  //state Kp_: float = Kp
  //state Kd_: float = Kd
  //state Ki_: float = Ki

  // limits for integral and total control signals
  state signal_i_max: float = INTEGRAL_CLAMPING_MAX
  state control_signal_max: float = CONTROL_LIMIT

  // timer_states
  state reference_tick: long = 0
  state now_tick: long = 0
  state interval_sec: float = 0.0

  preamble {=
    /*
    long reference_tick = 0;
    long now_tick = 0;
    long diff_tick = 0;
    float interval_sec = 0.0f;
    */
   int printcnt = 0;
   int printcnt_lim = 10;
    =}

  method doIntegralClamping(): void {=
    // do integral term clamping
    if ((self->signal_i_max) < (self->signal_i)){
      self->signal_i = self->signal_i_max;
    } 
    else if ((self->signal_i) < (-self->signal_i_max)){
      self->signal_i = -self->signal_i_max;
    }
    else {
      // nothing needs to be done.
    }
  =}

  method doControlSignalClamping(): void {=
    // do integral term clamping
    if ((self->control_signal_max) < (self->control_signal_)){
      self->control_signal_ = self->control_signal_max;
    } 
    else if ((self->control_signal_) < (-self->control_signal_max)){
      self->control_signal_ = -self->control_signal_max;
    }
    else {
      // nothing needs to be done.
    }
  =}

  reaction(startup){=
    self->reference_tick = HAL_GetTick();
    =}

  //reaction(update_tick) -> control_signal {=
  reaction(current_state, target_state) -> control_signal {=
    //instant_t now = lf_time_logical();
    //interval_t interval = now - self->prev_time;
    //self->prev_time = now;

    self->now_tick = HAL_GetTick(); // gives miliseconds since last stm32 reset
    self->interval_sec = ((float)(self->now_tick - self->reference_tick)) * MSEC_TO_SEC; // diff_tick
    self->reference_tick = self->now_tick;
    

    self->last_error = self->error;
    //self->error = (self->target_state_) - (self->current_state_);
    self->error = (target_state->value) - (current_state->value);

    self->signal_p = (self->error); // Kp * (error)
    self->signal_d = ((self->error - self->last_error) / self->interval_sec); // Kd * d(error)/dt
    self->signal_i = self->signal_i + (self->error * self->interval_sec); // ~  Ki * \sum_{t=0}^{t} (error) dt 

    doIntegralClamping();

    self->control_signal_ = self->Kp * self->signal_p + self->Kd * self->signal_d + self->Ki * self->signal_i; // sum all clamped components

    doControlSignalClamping();
    
    lf_set(control_signal, self->control_signal_);

    if (PRINT_PID_GENERIC && printcnt>=printcnt_lim){
      float print_mult = 10000.0;
      printf("target_state->value as int: %d\r\n", (int)(target_state->value * print_mult));
      printf("current_state->value as int: %d\r\n", (int)(current_state->value * print_mult));
      printf("self->_control_signal as int: %d\r\n", (int)(self->control_signal_ * print_mult));
      printf("interval: %ld ms\r\n", (int)(self->interval_sec * 1000));
    }

    printcnt = (printcnt >= printcnt_lim) ? 0 : printcnt+1;
  =}
}
