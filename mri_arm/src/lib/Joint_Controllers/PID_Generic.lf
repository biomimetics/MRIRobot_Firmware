target C {
  single-threaded: true,
  platform: {
    name: "stm32",
    board: "F446RE"
  }
}

preamble {=
  #include "stm32f4xx_hal.h"
  #include <stdio.h>

  #include <math.h>

  #define PRINT_PID_GENERIC 0
  #define printcnt_lim 5

  #define USE_REAL_TIME 1
  #define USE_INPUT_FILTER 1
=}

reactor PIDControllerGeneric(id: int = 0, error_deadband: float=0.000, do_feedforward:bool=false, control_signal_max:float=1000.0, integral_clamping_max:float=1000.0) {
  input Kp: float
  input Kd: float
  input Ki: float
  input reset_errors: bool
  
  input current_state: float
  input target_state: float
  output control_signal: float

  // internal copies of IO
  state current_state_: float = 0.0
  state target_state_: float = 0.0
  state control_signal_: float = 0.0

  // to help with state variables
  state last_error: float = 0.0  
  state prev_time: time = 0

  // error and control signal components
  state error: float = 0.0
  state signal_p: float = 0.0
  state signal_d: float = 0.0
  state signal_i: float = 0.0

  state Kp_: float = 0.0
  state Kd_: float = 0.0
  state Ki_: float = 0.0

  // limits for integral and total control signals
  state loop_period: float = 0.005 // if not using real time
  state integral_clamping_max_: float = integral_clamping_max
  state control_signal_max_: float = control_signal_max


  // timer_states
  state timer_start_: uint32_t = 0
  state timer_elapsed_time_sec_: double = 0.0
  state interval_sec: float = 0.0

  timer update_tick(0, 5 ms)

  state id_: int = id

  preamble {=

   int printcnt = 0;

   float filter_alpha = 0.7;
   float expFilterInput(float input, float old, float alpha){
    return (alpha) * input + (1.0 - alpha) * old;
   }
    =}

  method doErrorDeadbanding(): void {=
    if (fabsf(self->error) < self->error_deadband){
      self->error = 0.0;
    }
  =}

  method doIntegralClamping(): void {=
    // do integral term clamping
    if ((self->integral_clamping_max_) < (self->signal_i)){
      self->signal_i = self->integral_clamping_max_;
    } 
    else if ((self->signal_i) < (-self->integral_clamping_max_)){
      self->signal_i = -self->integral_clamping_max_;
    }
    else {
      // nothing needs to be done.
    }
  =}

  method doControlSignalClamping(): void {=

    // do integral term clamping
    if ((self->control_signal_max_) < (self->control_signal_)){
      self->control_signal_ = self->control_signal_max_;
    } 
    else if ((self->control_signal_) < (-self->control_signal_max_)){
      self->control_signal_ = -self->control_signal_max_;
    }
    else {
      // nothing needs to be done.
    }
  =}


  reaction(startup){=
    //self->reference_tick = HAL_GetTick();
    =}

  reaction(Kp){=
    self->Kp_ = Kp->value;
  =}
  reaction(Kd){=
    self->Kd_ = Kd->value;
  =}
  reaction(Ki){=
    self->Ki_ = Ki->value;
  =}

  reaction(current_state){=
    if (USE_INPUT_FILTER){
      self->current_state_ = expFilterInput(current_state->value, self->current_state_, filter_alpha);
    }
    else{
      self->current_state_ = current_state->value;
    }
    
  =}

  reaction(target_state){=
    if (USE_INPUT_FILTER){
      self->target_state_ = expFilterInput(target_state->value, self->target_state_, filter_alpha);
    }
    else{
      self->target_state_ = target_state->value;
    }
    
  =}

  reaction(reset_errors){=
    self->signal_p = 0.0;
    self->signal_i = 0.0;
    self->signal_d = 0.0;
    =}

  
  //reaction(update_tick) target_state, current_state -> control_signal {=
  reaction(current_state, target_state) -> control_signal {= // using this makes very inconsistent inputs!!!
    
    if (USE_REAL_TIME){
      timer_updated_elapsed_time(&self->timer_start_, &self->timer_elapsed_time_sec_); // comptues the interval in seconds
      self->interval_sec = (float) self->timer_elapsed_time_sec_;
    }
    else{
      self->interval_sec = self->loop_period;
    }
    
    self->last_error = self->error;
    //self->error = (self->target_state_) - (self->current_state_); 
    self->error = (target_state->value) - (current_state->value);
    doErrorDeadbanding(); // zeros out error if it's less than the deadband. if done here, doesn't propagate to control signals, likely more smooth

    self->signal_p = (self->error); // Kp * (error)
    self->signal_d = ((self->error - self->last_error) / self->interval_sec); // Kd * d(error)/dt
    self->signal_i = self->signal_i + (self->error * self->interval_sec); // ~  Ki * \sum_{t=0}^{t} (error) dt 

    doIntegralClamping();

    self->control_signal_ = self->Kp_ * self->signal_p + self->Kd_ * self->signal_d + self->Ki_ * self->signal_i; // sum all clamped components

    if (self->do_feedforward){
      self->control_signal_ = self->control_signal_ + target_state->value;
    }

    doControlSignalClamping();

    lf_set(control_signal, self->control_signal_);
    
    
    //lf_set(control_signal, self->control_signal_);

    if (PRINT_PID_GENERIC && printcnt>=printcnt_lim){
      float print_mult = 1000.0;
      printf("interval: %ld us\r\n", (int)(self->interval_sec * 1000000));
      printf("self->signal_p as int: %d\r\n", (int)(self->signal_p * print_mult));
      printf("self->signal_d as int: %d\r\n", (int)(self->signal_d * print_mult));
      printf("self->signal_i as int: %d\r\n", (int)(self->signal_i * print_mult));

      //printf("target_state->value as int: %d\r\n", (int)(target_state->value * print_mult));
      //printf("current_state->value as int: %d\r\n", (int)(current_state->value * print_mult));
      printf("self->target_state_ as int: %d\r\n", (int)(self->target_state_ * print_mult));
      printf("self->current_state_ as int: %d\r\n", (int)(self->current_state_ * print_mult));
      printf("self->control_signal_ as int: %d\r\n", (int)(self->control_signal_ * print_mult));
      
    }

    printcnt = (printcnt >= printcnt_lim) ? 0 : printcnt+1;
  =}
}
